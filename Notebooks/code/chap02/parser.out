Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    NEWLINE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> p exp ;
Rule 5     stmt -> s var exp ;
Rule 6     exp -> + exp exp
Rule 7     exp -> - exp exp
Rule 8     exp -> ( exp )
Rule 9     exp -> num
Rule 10    exp -> var
Rule 11    var -> x
Rule 12    var -> y
Rule 13    var -> z
Rule 14    num -> 0
Rule 15    num -> 1
Rule 16    num -> 2
Rule 17    num -> 3
Rule 18    num -> 4
Rule 19    num -> 5
Rule 20    num -> 6
Rule 21    num -> 7
Rule 22    num -> 8
Rule 23    num -> 9
Rule 24    empty -> <empty>

Terminals, with rules where they appear

(                    : 8
)                    : 8
+                    : 6
-                    : 7
0                    : 14
1                    : 15
2                    : 16
3                    : 17
4                    : 18
5                    : 19
6                    : 20
7                    : 21
8                    : 22
9                    : 23
;                    : 4 5
NEWLINE              : 
error                : 
p                    : 4
s                    : 5
x                    : 11
y                    : 12
z                    : 13

Nonterminals, with rules where they appear

empty                : 3
exp                  : 4 5 6 6 7 7 8
num                  : 9
prog                 : 0
stmt                 : 2
stmt_list            : 1 2
var                  : 5 10

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . p exp ;
    (5) stmt -> . s var exp ;
    (24) empty -> .

    p               shift and go to state 5
    s               shift and go to state 6
    $end            reduce using rule 24 (empty -> .)

    prog                           shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> prog .



state 2

    (1) prog -> stmt_list .

    $end            reduce using rule 1 (prog -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . p exp ;
    (5) stmt -> . s var exp ;
    (24) empty -> .

    p               shift and go to state 5
    s               shift and go to state 6
    $end            reduce using rule 24 (empty -> .)

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 7
    empty                          shift and go to state 4

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> p . exp ;
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 8
    num                            shift and go to state 12
    var                            shift and go to state 13

state 6

    (5) stmt -> s . var exp ;
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    var                            shift and go to state 27

state 7

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 8

    (4) stmt -> p exp . ;

    ;               shift and go to state 28


state 9

    (6) exp -> + . exp exp
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 29
    num                            shift and go to state 12
    var                            shift and go to state 13

state 10

    (7) exp -> - . exp exp
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 30
    num                            shift and go to state 12
    var                            shift and go to state 13

state 11

    (8) exp -> ( . exp )
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 31
    num                            shift and go to state 12
    var                            shift and go to state 13

state 12

    (9) exp -> num .

    ;               reduce using rule 9 (exp -> num .)
    +               reduce using rule 9 (exp -> num .)
    -               reduce using rule 9 (exp -> num .)
    (               reduce using rule 9 (exp -> num .)
    0               reduce using rule 9 (exp -> num .)
    1               reduce using rule 9 (exp -> num .)
    2               reduce using rule 9 (exp -> num .)
    3               reduce using rule 9 (exp -> num .)
    4               reduce using rule 9 (exp -> num .)
    5               reduce using rule 9 (exp -> num .)
    6               reduce using rule 9 (exp -> num .)
    7               reduce using rule 9 (exp -> num .)
    8               reduce using rule 9 (exp -> num .)
    9               reduce using rule 9 (exp -> num .)
    x               reduce using rule 9 (exp -> num .)
    y               reduce using rule 9 (exp -> num .)
    z               reduce using rule 9 (exp -> num .)
    )               reduce using rule 9 (exp -> num .)


state 13

    (10) exp -> var .

    ;               reduce using rule 10 (exp -> var .)
    +               reduce using rule 10 (exp -> var .)
    -               reduce using rule 10 (exp -> var .)
    (               reduce using rule 10 (exp -> var .)
    0               reduce using rule 10 (exp -> var .)
    1               reduce using rule 10 (exp -> var .)
    2               reduce using rule 10 (exp -> var .)
    3               reduce using rule 10 (exp -> var .)
    4               reduce using rule 10 (exp -> var .)
    5               reduce using rule 10 (exp -> var .)
    6               reduce using rule 10 (exp -> var .)
    7               reduce using rule 10 (exp -> var .)
    8               reduce using rule 10 (exp -> var .)
    9               reduce using rule 10 (exp -> var .)
    x               reduce using rule 10 (exp -> var .)
    y               reduce using rule 10 (exp -> var .)
    z               reduce using rule 10 (exp -> var .)
    )               reduce using rule 10 (exp -> var .)


state 14

    (14) num -> 0 .

    ;               reduce using rule 14 (num -> 0 .)
    +               reduce using rule 14 (num -> 0 .)
    -               reduce using rule 14 (num -> 0 .)
    (               reduce using rule 14 (num -> 0 .)
    0               reduce using rule 14 (num -> 0 .)
    1               reduce using rule 14 (num -> 0 .)
    2               reduce using rule 14 (num -> 0 .)
    3               reduce using rule 14 (num -> 0 .)
    4               reduce using rule 14 (num -> 0 .)
    5               reduce using rule 14 (num -> 0 .)
    6               reduce using rule 14 (num -> 0 .)
    7               reduce using rule 14 (num -> 0 .)
    8               reduce using rule 14 (num -> 0 .)
    9               reduce using rule 14 (num -> 0 .)
    x               reduce using rule 14 (num -> 0 .)
    y               reduce using rule 14 (num -> 0 .)
    z               reduce using rule 14 (num -> 0 .)
    )               reduce using rule 14 (num -> 0 .)


state 15

    (15) num -> 1 .

    ;               reduce using rule 15 (num -> 1 .)
    +               reduce using rule 15 (num -> 1 .)
    -               reduce using rule 15 (num -> 1 .)
    (               reduce using rule 15 (num -> 1 .)
    0               reduce using rule 15 (num -> 1 .)
    1               reduce using rule 15 (num -> 1 .)
    2               reduce using rule 15 (num -> 1 .)
    3               reduce using rule 15 (num -> 1 .)
    4               reduce using rule 15 (num -> 1 .)
    5               reduce using rule 15 (num -> 1 .)
    6               reduce using rule 15 (num -> 1 .)
    7               reduce using rule 15 (num -> 1 .)
    8               reduce using rule 15 (num -> 1 .)
    9               reduce using rule 15 (num -> 1 .)
    x               reduce using rule 15 (num -> 1 .)
    y               reduce using rule 15 (num -> 1 .)
    z               reduce using rule 15 (num -> 1 .)
    )               reduce using rule 15 (num -> 1 .)


state 16

    (16) num -> 2 .

    ;               reduce using rule 16 (num -> 2 .)
    +               reduce using rule 16 (num -> 2 .)
    -               reduce using rule 16 (num -> 2 .)
    (               reduce using rule 16 (num -> 2 .)
    0               reduce using rule 16 (num -> 2 .)
    1               reduce using rule 16 (num -> 2 .)
    2               reduce using rule 16 (num -> 2 .)
    3               reduce using rule 16 (num -> 2 .)
    4               reduce using rule 16 (num -> 2 .)
    5               reduce using rule 16 (num -> 2 .)
    6               reduce using rule 16 (num -> 2 .)
    7               reduce using rule 16 (num -> 2 .)
    8               reduce using rule 16 (num -> 2 .)
    9               reduce using rule 16 (num -> 2 .)
    x               reduce using rule 16 (num -> 2 .)
    y               reduce using rule 16 (num -> 2 .)
    z               reduce using rule 16 (num -> 2 .)
    )               reduce using rule 16 (num -> 2 .)


state 17

    (17) num -> 3 .

    ;               reduce using rule 17 (num -> 3 .)
    +               reduce using rule 17 (num -> 3 .)
    -               reduce using rule 17 (num -> 3 .)
    (               reduce using rule 17 (num -> 3 .)
    0               reduce using rule 17 (num -> 3 .)
    1               reduce using rule 17 (num -> 3 .)
    2               reduce using rule 17 (num -> 3 .)
    3               reduce using rule 17 (num -> 3 .)
    4               reduce using rule 17 (num -> 3 .)
    5               reduce using rule 17 (num -> 3 .)
    6               reduce using rule 17 (num -> 3 .)
    7               reduce using rule 17 (num -> 3 .)
    8               reduce using rule 17 (num -> 3 .)
    9               reduce using rule 17 (num -> 3 .)
    x               reduce using rule 17 (num -> 3 .)
    y               reduce using rule 17 (num -> 3 .)
    z               reduce using rule 17 (num -> 3 .)
    )               reduce using rule 17 (num -> 3 .)


state 18

    (18) num -> 4 .

    ;               reduce using rule 18 (num -> 4 .)
    +               reduce using rule 18 (num -> 4 .)
    -               reduce using rule 18 (num -> 4 .)
    (               reduce using rule 18 (num -> 4 .)
    0               reduce using rule 18 (num -> 4 .)
    1               reduce using rule 18 (num -> 4 .)
    2               reduce using rule 18 (num -> 4 .)
    3               reduce using rule 18 (num -> 4 .)
    4               reduce using rule 18 (num -> 4 .)
    5               reduce using rule 18 (num -> 4 .)
    6               reduce using rule 18 (num -> 4 .)
    7               reduce using rule 18 (num -> 4 .)
    8               reduce using rule 18 (num -> 4 .)
    9               reduce using rule 18 (num -> 4 .)
    x               reduce using rule 18 (num -> 4 .)
    y               reduce using rule 18 (num -> 4 .)
    z               reduce using rule 18 (num -> 4 .)
    )               reduce using rule 18 (num -> 4 .)


state 19

    (19) num -> 5 .

    ;               reduce using rule 19 (num -> 5 .)
    +               reduce using rule 19 (num -> 5 .)
    -               reduce using rule 19 (num -> 5 .)
    (               reduce using rule 19 (num -> 5 .)
    0               reduce using rule 19 (num -> 5 .)
    1               reduce using rule 19 (num -> 5 .)
    2               reduce using rule 19 (num -> 5 .)
    3               reduce using rule 19 (num -> 5 .)
    4               reduce using rule 19 (num -> 5 .)
    5               reduce using rule 19 (num -> 5 .)
    6               reduce using rule 19 (num -> 5 .)
    7               reduce using rule 19 (num -> 5 .)
    8               reduce using rule 19 (num -> 5 .)
    9               reduce using rule 19 (num -> 5 .)
    x               reduce using rule 19 (num -> 5 .)
    y               reduce using rule 19 (num -> 5 .)
    z               reduce using rule 19 (num -> 5 .)
    )               reduce using rule 19 (num -> 5 .)


state 20

    (20) num -> 6 .

    ;               reduce using rule 20 (num -> 6 .)
    +               reduce using rule 20 (num -> 6 .)
    -               reduce using rule 20 (num -> 6 .)
    (               reduce using rule 20 (num -> 6 .)
    0               reduce using rule 20 (num -> 6 .)
    1               reduce using rule 20 (num -> 6 .)
    2               reduce using rule 20 (num -> 6 .)
    3               reduce using rule 20 (num -> 6 .)
    4               reduce using rule 20 (num -> 6 .)
    5               reduce using rule 20 (num -> 6 .)
    6               reduce using rule 20 (num -> 6 .)
    7               reduce using rule 20 (num -> 6 .)
    8               reduce using rule 20 (num -> 6 .)
    9               reduce using rule 20 (num -> 6 .)
    x               reduce using rule 20 (num -> 6 .)
    y               reduce using rule 20 (num -> 6 .)
    z               reduce using rule 20 (num -> 6 .)
    )               reduce using rule 20 (num -> 6 .)


state 21

    (21) num -> 7 .

    ;               reduce using rule 21 (num -> 7 .)
    +               reduce using rule 21 (num -> 7 .)
    -               reduce using rule 21 (num -> 7 .)
    (               reduce using rule 21 (num -> 7 .)
    0               reduce using rule 21 (num -> 7 .)
    1               reduce using rule 21 (num -> 7 .)
    2               reduce using rule 21 (num -> 7 .)
    3               reduce using rule 21 (num -> 7 .)
    4               reduce using rule 21 (num -> 7 .)
    5               reduce using rule 21 (num -> 7 .)
    6               reduce using rule 21 (num -> 7 .)
    7               reduce using rule 21 (num -> 7 .)
    8               reduce using rule 21 (num -> 7 .)
    9               reduce using rule 21 (num -> 7 .)
    x               reduce using rule 21 (num -> 7 .)
    y               reduce using rule 21 (num -> 7 .)
    z               reduce using rule 21 (num -> 7 .)
    )               reduce using rule 21 (num -> 7 .)


state 22

    (22) num -> 8 .

    ;               reduce using rule 22 (num -> 8 .)
    +               reduce using rule 22 (num -> 8 .)
    -               reduce using rule 22 (num -> 8 .)
    (               reduce using rule 22 (num -> 8 .)
    0               reduce using rule 22 (num -> 8 .)
    1               reduce using rule 22 (num -> 8 .)
    2               reduce using rule 22 (num -> 8 .)
    3               reduce using rule 22 (num -> 8 .)
    4               reduce using rule 22 (num -> 8 .)
    5               reduce using rule 22 (num -> 8 .)
    6               reduce using rule 22 (num -> 8 .)
    7               reduce using rule 22 (num -> 8 .)
    8               reduce using rule 22 (num -> 8 .)
    9               reduce using rule 22 (num -> 8 .)
    x               reduce using rule 22 (num -> 8 .)
    y               reduce using rule 22 (num -> 8 .)
    z               reduce using rule 22 (num -> 8 .)
    )               reduce using rule 22 (num -> 8 .)


state 23

    (23) num -> 9 .

    ;               reduce using rule 23 (num -> 9 .)
    +               reduce using rule 23 (num -> 9 .)
    -               reduce using rule 23 (num -> 9 .)
    (               reduce using rule 23 (num -> 9 .)
    0               reduce using rule 23 (num -> 9 .)
    1               reduce using rule 23 (num -> 9 .)
    2               reduce using rule 23 (num -> 9 .)
    3               reduce using rule 23 (num -> 9 .)
    4               reduce using rule 23 (num -> 9 .)
    5               reduce using rule 23 (num -> 9 .)
    6               reduce using rule 23 (num -> 9 .)
    7               reduce using rule 23 (num -> 9 .)
    8               reduce using rule 23 (num -> 9 .)
    9               reduce using rule 23 (num -> 9 .)
    x               reduce using rule 23 (num -> 9 .)
    y               reduce using rule 23 (num -> 9 .)
    z               reduce using rule 23 (num -> 9 .)
    )               reduce using rule 23 (num -> 9 .)


state 24

    (11) var -> x .

    ;               reduce using rule 11 (var -> x .)
    +               reduce using rule 11 (var -> x .)
    -               reduce using rule 11 (var -> x .)
    (               reduce using rule 11 (var -> x .)
    0               reduce using rule 11 (var -> x .)
    1               reduce using rule 11 (var -> x .)
    2               reduce using rule 11 (var -> x .)
    3               reduce using rule 11 (var -> x .)
    4               reduce using rule 11 (var -> x .)
    5               reduce using rule 11 (var -> x .)
    6               reduce using rule 11 (var -> x .)
    7               reduce using rule 11 (var -> x .)
    8               reduce using rule 11 (var -> x .)
    9               reduce using rule 11 (var -> x .)
    x               reduce using rule 11 (var -> x .)
    y               reduce using rule 11 (var -> x .)
    z               reduce using rule 11 (var -> x .)
    )               reduce using rule 11 (var -> x .)


state 25

    (12) var -> y .

    ;               reduce using rule 12 (var -> y .)
    +               reduce using rule 12 (var -> y .)
    -               reduce using rule 12 (var -> y .)
    (               reduce using rule 12 (var -> y .)
    0               reduce using rule 12 (var -> y .)
    1               reduce using rule 12 (var -> y .)
    2               reduce using rule 12 (var -> y .)
    3               reduce using rule 12 (var -> y .)
    4               reduce using rule 12 (var -> y .)
    5               reduce using rule 12 (var -> y .)
    6               reduce using rule 12 (var -> y .)
    7               reduce using rule 12 (var -> y .)
    8               reduce using rule 12 (var -> y .)
    9               reduce using rule 12 (var -> y .)
    x               reduce using rule 12 (var -> y .)
    y               reduce using rule 12 (var -> y .)
    z               reduce using rule 12 (var -> y .)
    )               reduce using rule 12 (var -> y .)


state 26

    (13) var -> z .

    ;               reduce using rule 13 (var -> z .)
    +               reduce using rule 13 (var -> z .)
    -               reduce using rule 13 (var -> z .)
    (               reduce using rule 13 (var -> z .)
    0               reduce using rule 13 (var -> z .)
    1               reduce using rule 13 (var -> z .)
    2               reduce using rule 13 (var -> z .)
    3               reduce using rule 13 (var -> z .)
    4               reduce using rule 13 (var -> z .)
    5               reduce using rule 13 (var -> z .)
    6               reduce using rule 13 (var -> z .)
    7               reduce using rule 13 (var -> z .)
    8               reduce using rule 13 (var -> z .)
    9               reduce using rule 13 (var -> z .)
    x               reduce using rule 13 (var -> z .)
    y               reduce using rule 13 (var -> z .)
    z               reduce using rule 13 (var -> z .)
    )               reduce using rule 13 (var -> z .)


state 27

    (5) stmt -> s var . exp ;
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    var                            shift and go to state 13
    exp                            shift and go to state 32
    num                            shift and go to state 12

state 28

    (4) stmt -> p exp ; .

    p               reduce using rule 4 (stmt -> p exp ; .)
    s               reduce using rule 4 (stmt -> p exp ; .)
    $end            reduce using rule 4 (stmt -> p exp ; .)


state 29

    (6) exp -> + exp . exp
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 33
    num                            shift and go to state 12
    var                            shift and go to state 13

state 30

    (7) exp -> - exp . exp
    (6) exp -> . + exp exp
    (7) exp -> . - exp exp
    (8) exp -> . ( exp )
    (9) exp -> . num
    (10) exp -> . var
    (14) num -> . 0
    (15) num -> . 1
    (16) num -> . 2
    (17) num -> . 3
    (18) num -> . 4
    (19) num -> . 5
    (20) num -> . 6
    (21) num -> . 7
    (22) num -> . 8
    (23) num -> . 9
    (11) var -> . x
    (12) var -> . y
    (13) var -> . z

    +               shift and go to state 9
    -               shift and go to state 10
    (               shift and go to state 11
    0               shift and go to state 14
    1               shift and go to state 15
    2               shift and go to state 16
    3               shift and go to state 17
    4               shift and go to state 18
    5               shift and go to state 19
    6               shift and go to state 20
    7               shift and go to state 21
    8               shift and go to state 22
    9               shift and go to state 23
    x               shift and go to state 24
    y               shift and go to state 25
    z               shift and go to state 26

    exp                            shift and go to state 34
    num                            shift and go to state 12
    var                            shift and go to state 13

state 31

    (8) exp -> ( exp . )

    )               shift and go to state 35


state 32

    (5) stmt -> s var exp . ;

    ;               shift and go to state 36


state 33

    (6) exp -> + exp exp .

    ;               reduce using rule 6 (exp -> + exp exp .)
    +               reduce using rule 6 (exp -> + exp exp .)
    -               reduce using rule 6 (exp -> + exp exp .)
    (               reduce using rule 6 (exp -> + exp exp .)
    0               reduce using rule 6 (exp -> + exp exp .)
    1               reduce using rule 6 (exp -> + exp exp .)
    2               reduce using rule 6 (exp -> + exp exp .)
    3               reduce using rule 6 (exp -> + exp exp .)
    4               reduce using rule 6 (exp -> + exp exp .)
    5               reduce using rule 6 (exp -> + exp exp .)
    6               reduce using rule 6 (exp -> + exp exp .)
    7               reduce using rule 6 (exp -> + exp exp .)
    8               reduce using rule 6 (exp -> + exp exp .)
    9               reduce using rule 6 (exp -> + exp exp .)
    x               reduce using rule 6 (exp -> + exp exp .)
    y               reduce using rule 6 (exp -> + exp exp .)
    z               reduce using rule 6 (exp -> + exp exp .)
    )               reduce using rule 6 (exp -> + exp exp .)


state 34

    (7) exp -> - exp exp .

    ;               reduce using rule 7 (exp -> - exp exp .)
    +               reduce using rule 7 (exp -> - exp exp .)
    -               reduce using rule 7 (exp -> - exp exp .)
    (               reduce using rule 7 (exp -> - exp exp .)
    0               reduce using rule 7 (exp -> - exp exp .)
    1               reduce using rule 7 (exp -> - exp exp .)
    2               reduce using rule 7 (exp -> - exp exp .)
    3               reduce using rule 7 (exp -> - exp exp .)
    4               reduce using rule 7 (exp -> - exp exp .)
    5               reduce using rule 7 (exp -> - exp exp .)
    6               reduce using rule 7 (exp -> - exp exp .)
    7               reduce using rule 7 (exp -> - exp exp .)
    8               reduce using rule 7 (exp -> - exp exp .)
    9               reduce using rule 7 (exp -> - exp exp .)
    x               reduce using rule 7 (exp -> - exp exp .)
    y               reduce using rule 7 (exp -> - exp exp .)
    z               reduce using rule 7 (exp -> - exp exp .)
    )               reduce using rule 7 (exp -> - exp exp .)


state 35

    (8) exp -> ( exp ) .

    ;               reduce using rule 8 (exp -> ( exp ) .)
    +               reduce using rule 8 (exp -> ( exp ) .)
    -               reduce using rule 8 (exp -> ( exp ) .)
    (               reduce using rule 8 (exp -> ( exp ) .)
    0               reduce using rule 8 (exp -> ( exp ) .)
    1               reduce using rule 8 (exp -> ( exp ) .)
    2               reduce using rule 8 (exp -> ( exp ) .)
    3               reduce using rule 8 (exp -> ( exp ) .)
    4               reduce using rule 8 (exp -> ( exp ) .)
    5               reduce using rule 8 (exp -> ( exp ) .)
    6               reduce using rule 8 (exp -> ( exp ) .)
    7               reduce using rule 8 (exp -> ( exp ) .)
    8               reduce using rule 8 (exp -> ( exp ) .)
    9               reduce using rule 8 (exp -> ( exp ) .)
    x               reduce using rule 8 (exp -> ( exp ) .)
    y               reduce using rule 8 (exp -> ( exp ) .)
    z               reduce using rule 8 (exp -> ( exp ) .)
    )               reduce using rule 8 (exp -> ( exp ) .)


state 36

    (5) stmt -> s var exp ; .

    p               reduce using rule 5 (stmt -> s var exp ; .)
    s               reduce using rule 5 (stmt -> s var exp ; .)
    $end            reduce using rule 5 (stmt -> s var exp ; .)

