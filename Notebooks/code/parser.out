Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> DECLARE ID ( opt_formal_args ) stmt
Rule 5     stmt -> DECLARE ID opt_init opt_semi
Rule 6     stmt -> ID = exp opt_semi
Rule 7     stmt -> GET ID opt_semi
Rule 8     stmt -> PUT exp opt_semi
Rule 9     stmt -> ID ( opt_actual_args ) opt_semi
Rule 10    stmt -> RETURN opt_exp opt_semi
Rule 11    stmt -> WHILE ( exp ) stmt
Rule 12    stmt -> IF ( exp ) stmt opt_else
Rule 13    stmt -> { stmt_list }
Rule 14    opt_formal_args -> formal_args
Rule 15    opt_formal_args -> empty
Rule 16    formal_args -> ID , formal_args
Rule 17    formal_args -> ID
Rule 18    opt_init -> = exp
Rule 19    opt_init -> empty
Rule 20    opt_actual_args -> actual_args
Rule 21    opt_actual_args -> empty
Rule 22    actual_args -> exp , actual_args
Rule 23    actual_args -> exp
Rule 24    opt_exp -> exp
Rule 25    opt_exp -> empty
Rule 26    opt_else -> ELSE stmt
Rule 27    opt_else -> empty
Rule 28    opt_semi -> ;
Rule 29    opt_semi -> empty
Rule 30    exp -> exp PLUS exp
Rule 31    exp -> exp MINUS exp
Rule 32    exp -> exp TIMES exp
Rule 33    exp -> exp DIVIDE exp
Rule 34    exp -> exp EQ exp
Rule 35    exp -> exp LE exp
Rule 36    exp -> INTEGER
Rule 37    exp -> ID
Rule 38    exp -> ID ( opt_actual_args )
Rule 39    exp -> ( exp )
Rule 40    exp -> MINUS exp
Rule 41    exp -> NOT exp
Rule 42    empty -> <empty>

Terminals, with rules where they appear

(                    : 4 9 11 12 38 39
)                    : 4 9 11 12 38 39
,                    : 16 22
;                    : 28
=                    : 6 18
DECLARE              : 4 5
DIVIDE               : 33
ELSE                 : 26
EQ                   : 34
GET                  : 7
ID                   : 4 5 6 7 9 16 17 37 38
IF                   : 12
INTEGER              : 36
LE                   : 35
MINUS                : 31 40
NOT                  : 41
PLUS                 : 30
PUT                  : 8
RETURN               : 10
TIMES                : 32
WHILE                : 11
error                : 
{                    : 13
}                    : 13

Nonterminals, with rules where they appear

actual_args          : 20 22
empty                : 3 15 19 21 25 27 29
exp                  : 6 8 11 12 18 22 23 24 30 30 31 31 32 32 33 33 34 34 35 35 39 40 41
formal_args          : 14 16
opt_actual_args      : 9 38
opt_else             : 12
opt_exp              : 10
opt_formal_args      : 4
opt_init             : 5
opt_semi             : 5 6 7 8 9 10
program              : 0
stmt                 : 2 4 11 12 26
stmt_list            : 1 2 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }
    (42) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    $end            reduce using rule 42 (empty -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }
    (42) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 13
    empty                          shift and go to state 4

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)
    }               reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> DECLARE . ID ( opt_formal_args ) stmt
    (5) stmt -> DECLARE . ID opt_init opt_semi

    ID              shift and go to state 14


state 6

    (6) stmt -> ID . = exp opt_semi
    (9) stmt -> ID . ( opt_actual_args ) opt_semi

    =               shift and go to state 15
    (               shift and go to state 16


state 7

    (7) stmt -> GET . ID opt_semi

    ID              shift and go to state 17


state 8

    (8) stmt -> PUT . exp opt_semi
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 18

state 9

    (10) stmt -> RETURN . opt_exp opt_semi
    (24) opt_exp -> . exp
    (25) opt_exp -> . empty
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp
    (42) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23
    ;               reduce using rule 42 (empty -> .)
    DECLARE         reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

  ! ID              [ reduce using rule 42 (empty -> .) ]

    opt_exp                        shift and go to state 24
    exp                            shift and go to state 25
    empty                          shift and go to state 26

state 10

    (11) stmt -> WHILE . ( exp ) stmt

    (               shift and go to state 27


state 11

    (12) stmt -> IF . ( exp ) stmt opt_else

    (               shift and go to state 28


state 12

    (13) stmt -> { . stmt_list }
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }
    (42) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12
    }               reduce using rule 42 (empty -> .)

    stmt_list                      shift and go to state 29
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 13

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    }               reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 14

    (4) stmt -> DECLARE ID . ( opt_formal_args ) stmt
    (5) stmt -> DECLARE ID . opt_init opt_semi
    (18) opt_init -> . = exp
    (19) opt_init -> . empty
    (42) empty -> .

    (               shift and go to state 30
    =               shift and go to state 32
    ;               reduce using rule 42 (empty -> .)
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_init                       shift and go to state 31
    empty                          shift and go to state 33

state 15

    (6) stmt -> ID = . exp opt_semi
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 34

state 16

    (9) stmt -> ID ( . opt_actual_args ) opt_semi
    (20) opt_actual_args -> . actual_args
    (21) opt_actual_args -> . empty
    (22) actual_args -> . exp , actual_args
    (23) actual_args -> . exp
    (42) empty -> .
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    )               reduce using rule 42 (empty -> .)
    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    opt_actual_args                shift and go to state 35
    actual_args                    shift and go to state 36
    empty                          shift and go to state 37
    exp                            shift and go to state 38

state 17

    (7) stmt -> GET ID . opt_semi
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 39
    empty                          shift and go to state 41

state 18

    (8) stmt -> PUT exp . opt_semi
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48
    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 42
    empty                          shift and go to state 41

state 19

    (40) exp -> MINUS . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 49

state 20

    (36) exp -> INTEGER .

    PLUS            reduce using rule 36 (exp -> INTEGER .)
    MINUS           reduce using rule 36 (exp -> INTEGER .)
    TIMES           reduce using rule 36 (exp -> INTEGER .)
    DIVIDE          reduce using rule 36 (exp -> INTEGER .)
    EQ              reduce using rule 36 (exp -> INTEGER .)
    LE              reduce using rule 36 (exp -> INTEGER .)
    ;               reduce using rule 36 (exp -> INTEGER .)
    DECLARE         reduce using rule 36 (exp -> INTEGER .)
    ID              reduce using rule 36 (exp -> INTEGER .)
    GET             reduce using rule 36 (exp -> INTEGER .)
    PUT             reduce using rule 36 (exp -> INTEGER .)
    RETURN          reduce using rule 36 (exp -> INTEGER .)
    WHILE           reduce using rule 36 (exp -> INTEGER .)
    IF              reduce using rule 36 (exp -> INTEGER .)
    {               reduce using rule 36 (exp -> INTEGER .)
    $end            reduce using rule 36 (exp -> INTEGER .)
    }               reduce using rule 36 (exp -> INTEGER .)
    ELSE            reduce using rule 36 (exp -> INTEGER .)
    ,               reduce using rule 36 (exp -> INTEGER .)
    )               reduce using rule 36 (exp -> INTEGER .)


state 21

    (37) exp -> ID .
    (38) exp -> ID . ( opt_actual_args )

    PLUS            reduce using rule 37 (exp -> ID .)
    MINUS           reduce using rule 37 (exp -> ID .)
    TIMES           reduce using rule 37 (exp -> ID .)
    DIVIDE          reduce using rule 37 (exp -> ID .)
    EQ              reduce using rule 37 (exp -> ID .)
    LE              reduce using rule 37 (exp -> ID .)
    ;               reduce using rule 37 (exp -> ID .)
    DECLARE         reduce using rule 37 (exp -> ID .)
    ID              reduce using rule 37 (exp -> ID .)
    GET             reduce using rule 37 (exp -> ID .)
    PUT             reduce using rule 37 (exp -> ID .)
    RETURN          reduce using rule 37 (exp -> ID .)
    WHILE           reduce using rule 37 (exp -> ID .)
    IF              reduce using rule 37 (exp -> ID .)
    {               reduce using rule 37 (exp -> ID .)
    $end            reduce using rule 37 (exp -> ID .)
    }               reduce using rule 37 (exp -> ID .)
    ELSE            reduce using rule 37 (exp -> ID .)
    ,               reduce using rule 37 (exp -> ID .)
    )               reduce using rule 37 (exp -> ID .)
    (               shift and go to state 50


state 22

    (39) exp -> ( . exp )
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 51

state 23

    (41) exp -> NOT . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 52

state 24

    (10) stmt -> RETURN opt_exp . opt_semi
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 53
    empty                          shift and go to state 41

state 25

    (24) opt_exp -> exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    ;               reduce using rule 24 (opt_exp -> exp .)
    DECLARE         reduce using rule 24 (opt_exp -> exp .)
    ID              reduce using rule 24 (opt_exp -> exp .)
    GET             reduce using rule 24 (opt_exp -> exp .)
    PUT             reduce using rule 24 (opt_exp -> exp .)
    RETURN          reduce using rule 24 (opt_exp -> exp .)
    WHILE           reduce using rule 24 (opt_exp -> exp .)
    IF              reduce using rule 24 (opt_exp -> exp .)
    {               reduce using rule 24 (opt_exp -> exp .)
    $end            reduce using rule 24 (opt_exp -> exp .)
    }               reduce using rule 24 (opt_exp -> exp .)
    ELSE            reduce using rule 24 (opt_exp -> exp .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 26

    (25) opt_exp -> empty .

    ;               reduce using rule 25 (opt_exp -> empty .)
    DECLARE         reduce using rule 25 (opt_exp -> empty .)
    ID              reduce using rule 25 (opt_exp -> empty .)
    GET             reduce using rule 25 (opt_exp -> empty .)
    PUT             reduce using rule 25 (opt_exp -> empty .)
    RETURN          reduce using rule 25 (opt_exp -> empty .)
    WHILE           reduce using rule 25 (opt_exp -> empty .)
    IF              reduce using rule 25 (opt_exp -> empty .)
    {               reduce using rule 25 (opt_exp -> empty .)
    $end            reduce using rule 25 (opt_exp -> empty .)
    }               reduce using rule 25 (opt_exp -> empty .)
    ELSE            reduce using rule 25 (opt_exp -> empty .)


state 27

    (11) stmt -> WHILE ( . exp ) stmt
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 54

state 28

    (12) stmt -> IF ( . exp ) stmt opt_else
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 55

state 29

    (13) stmt -> { stmt_list . }

    }               shift and go to state 56


state 30

    (4) stmt -> DECLARE ID ( . opt_formal_args ) stmt
    (14) opt_formal_args -> . formal_args
    (15) opt_formal_args -> . empty
    (16) formal_args -> . ID , formal_args
    (17) formal_args -> . ID
    (42) empty -> .

    ID              shift and go to state 57
    )               reduce using rule 42 (empty -> .)

    opt_formal_args                shift and go to state 58
    formal_args                    shift and go to state 59
    empty                          shift and go to state 60

state 31

    (5) stmt -> DECLARE ID opt_init . opt_semi
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 61
    empty                          shift and go to state 41

state 32

    (18) opt_init -> = . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 62

state 33

    (19) opt_init -> empty .

    ;               reduce using rule 19 (opt_init -> empty .)
    DECLARE         reduce using rule 19 (opt_init -> empty .)
    ID              reduce using rule 19 (opt_init -> empty .)
    GET             reduce using rule 19 (opt_init -> empty .)
    PUT             reduce using rule 19 (opt_init -> empty .)
    RETURN          reduce using rule 19 (opt_init -> empty .)
    WHILE           reduce using rule 19 (opt_init -> empty .)
    IF              reduce using rule 19 (opt_init -> empty .)
    {               reduce using rule 19 (opt_init -> empty .)
    $end            reduce using rule 19 (opt_init -> empty .)
    }               reduce using rule 19 (opt_init -> empty .)
    ELSE            reduce using rule 19 (opt_init -> empty .)


state 34

    (6) stmt -> ID = exp . opt_semi
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48
    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 63
    empty                          shift and go to state 41

state 35

    (9) stmt -> ID ( opt_actual_args . ) opt_semi

    )               shift and go to state 64


state 36

    (20) opt_actual_args -> actual_args .

    )               reduce using rule 20 (opt_actual_args -> actual_args .)


state 37

    (21) opt_actual_args -> empty .

    )               reduce using rule 21 (opt_actual_args -> empty .)


state 38

    (22) actual_args -> exp . , actual_args
    (23) actual_args -> exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    ,               shift and go to state 65
    )               reduce using rule 23 (actual_args -> exp .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 39

    (7) stmt -> GET ID opt_semi .

    DECLARE         reduce using rule 7 (stmt -> GET ID opt_semi .)
    ID              reduce using rule 7 (stmt -> GET ID opt_semi .)
    GET             reduce using rule 7 (stmt -> GET ID opt_semi .)
    PUT             reduce using rule 7 (stmt -> GET ID opt_semi .)
    RETURN          reduce using rule 7 (stmt -> GET ID opt_semi .)
    WHILE           reduce using rule 7 (stmt -> GET ID opt_semi .)
    IF              reduce using rule 7 (stmt -> GET ID opt_semi .)
    {               reduce using rule 7 (stmt -> GET ID opt_semi .)
    $end            reduce using rule 7 (stmt -> GET ID opt_semi .)
    }               reduce using rule 7 (stmt -> GET ID opt_semi .)
    ELSE            reduce using rule 7 (stmt -> GET ID opt_semi .)


state 40

    (28) opt_semi -> ; .

    DECLARE         reduce using rule 28 (opt_semi -> ; .)
    ID              reduce using rule 28 (opt_semi -> ; .)
    GET             reduce using rule 28 (opt_semi -> ; .)
    PUT             reduce using rule 28 (opt_semi -> ; .)
    RETURN          reduce using rule 28 (opt_semi -> ; .)
    WHILE           reduce using rule 28 (opt_semi -> ; .)
    IF              reduce using rule 28 (opt_semi -> ; .)
    {               reduce using rule 28 (opt_semi -> ; .)
    $end            reduce using rule 28 (opt_semi -> ; .)
    }               reduce using rule 28 (opt_semi -> ; .)
    ELSE            reduce using rule 28 (opt_semi -> ; .)


state 41

    (29) opt_semi -> empty .

    DECLARE         reduce using rule 29 (opt_semi -> empty .)
    ID              reduce using rule 29 (opt_semi -> empty .)
    GET             reduce using rule 29 (opt_semi -> empty .)
    PUT             reduce using rule 29 (opt_semi -> empty .)
    RETURN          reduce using rule 29 (opt_semi -> empty .)
    WHILE           reduce using rule 29 (opt_semi -> empty .)
    IF              reduce using rule 29 (opt_semi -> empty .)
    {               reduce using rule 29 (opt_semi -> empty .)
    $end            reduce using rule 29 (opt_semi -> empty .)
    }               reduce using rule 29 (opt_semi -> empty .)
    ELSE            reduce using rule 29 (opt_semi -> empty .)


state 42

    (8) stmt -> PUT exp opt_semi .

    DECLARE         reduce using rule 8 (stmt -> PUT exp opt_semi .)
    ID              reduce using rule 8 (stmt -> PUT exp opt_semi .)
    GET             reduce using rule 8 (stmt -> PUT exp opt_semi .)
    PUT             reduce using rule 8 (stmt -> PUT exp opt_semi .)
    RETURN          reduce using rule 8 (stmt -> PUT exp opt_semi .)
    WHILE           reduce using rule 8 (stmt -> PUT exp opt_semi .)
    IF              reduce using rule 8 (stmt -> PUT exp opt_semi .)
    {               reduce using rule 8 (stmt -> PUT exp opt_semi .)
    $end            reduce using rule 8 (stmt -> PUT exp opt_semi .)
    }               reduce using rule 8 (stmt -> PUT exp opt_semi .)
    ELSE            reduce using rule 8 (stmt -> PUT exp opt_semi .)


state 43

    (30) exp -> exp PLUS . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 66

state 44

    (31) exp -> exp MINUS . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 67

state 45

    (32) exp -> exp TIMES . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 68

state 46

    (33) exp -> exp DIVIDE . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 69

state 47

    (34) exp -> exp EQ . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 70

state 48

    (35) exp -> exp LE . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 71

state 49

    (40) exp -> MINUS exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 40 (exp -> MINUS exp .)
    MINUS           reduce using rule 40 (exp -> MINUS exp .)
    TIMES           reduce using rule 40 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 40 (exp -> MINUS exp .)
    EQ              reduce using rule 40 (exp -> MINUS exp .)
    LE              reduce using rule 40 (exp -> MINUS exp .)
    ;               reduce using rule 40 (exp -> MINUS exp .)
    DECLARE         reduce using rule 40 (exp -> MINUS exp .)
    ID              reduce using rule 40 (exp -> MINUS exp .)
    GET             reduce using rule 40 (exp -> MINUS exp .)
    PUT             reduce using rule 40 (exp -> MINUS exp .)
    RETURN          reduce using rule 40 (exp -> MINUS exp .)
    WHILE           reduce using rule 40 (exp -> MINUS exp .)
    IF              reduce using rule 40 (exp -> MINUS exp .)
    {               reduce using rule 40 (exp -> MINUS exp .)
    $end            reduce using rule 40 (exp -> MINUS exp .)
    }               reduce using rule 40 (exp -> MINUS exp .)
    ELSE            reduce using rule 40 (exp -> MINUS exp .)
    ,               reduce using rule 40 (exp -> MINUS exp .)
    )               reduce using rule 40 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! TIMES           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 46 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 50

    (38) exp -> ID ( . opt_actual_args )
    (20) opt_actual_args -> . actual_args
    (21) opt_actual_args -> . empty
    (22) actual_args -> . exp , actual_args
    (23) actual_args -> . exp
    (42) empty -> .
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    )               reduce using rule 42 (empty -> .)
    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    opt_actual_args                shift and go to state 72
    actual_args                    shift and go to state 36
    empty                          shift and go to state 37
    exp                            shift and go to state 38

state 51

    (39) exp -> ( exp . )
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    )               shift and go to state 73
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 52

    (41) exp -> NOT exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 41 (exp -> NOT exp .)
    MINUS           reduce using rule 41 (exp -> NOT exp .)
    TIMES           reduce using rule 41 (exp -> NOT exp .)
    DIVIDE          reduce using rule 41 (exp -> NOT exp .)
    EQ              reduce using rule 41 (exp -> NOT exp .)
    LE              reduce using rule 41 (exp -> NOT exp .)
    ;               reduce using rule 41 (exp -> NOT exp .)
    DECLARE         reduce using rule 41 (exp -> NOT exp .)
    ID              reduce using rule 41 (exp -> NOT exp .)
    GET             reduce using rule 41 (exp -> NOT exp .)
    PUT             reduce using rule 41 (exp -> NOT exp .)
    RETURN          reduce using rule 41 (exp -> NOT exp .)
    WHILE           reduce using rule 41 (exp -> NOT exp .)
    IF              reduce using rule 41 (exp -> NOT exp .)
    {               reduce using rule 41 (exp -> NOT exp .)
    $end            reduce using rule 41 (exp -> NOT exp .)
    }               reduce using rule 41 (exp -> NOT exp .)
    ELSE            reduce using rule 41 (exp -> NOT exp .)
    ,               reduce using rule 41 (exp -> NOT exp .)
    )               reduce using rule 41 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! TIMES           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 46 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 53

    (10) stmt -> RETURN opt_exp opt_semi .

    DECLARE         reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    ID              reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    GET             reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    PUT             reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    RETURN          reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    WHILE           reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    IF              reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    {               reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    $end            reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    }               reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)
    ELSE            reduce using rule 10 (stmt -> RETURN opt_exp opt_semi .)


state 54

    (11) stmt -> WHILE ( exp . ) stmt
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    )               shift and go to state 74
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 55

    (12) stmt -> IF ( exp . ) stmt opt_else
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    )               shift and go to state 75
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 56

    (13) stmt -> { stmt_list } .

    DECLARE         reduce using rule 13 (stmt -> { stmt_list } .)
    ID              reduce using rule 13 (stmt -> { stmt_list } .)
    GET             reduce using rule 13 (stmt -> { stmt_list } .)
    PUT             reduce using rule 13 (stmt -> { stmt_list } .)
    RETURN          reduce using rule 13 (stmt -> { stmt_list } .)
    WHILE           reduce using rule 13 (stmt -> { stmt_list } .)
    IF              reduce using rule 13 (stmt -> { stmt_list } .)
    {               reduce using rule 13 (stmt -> { stmt_list } .)
    $end            reduce using rule 13 (stmt -> { stmt_list } .)
    }               reduce using rule 13 (stmt -> { stmt_list } .)
    ELSE            reduce using rule 13 (stmt -> { stmt_list } .)


state 57

    (16) formal_args -> ID . , formal_args
    (17) formal_args -> ID .

    ,               shift and go to state 76
    )               reduce using rule 17 (formal_args -> ID .)


state 58

    (4) stmt -> DECLARE ID ( opt_formal_args . ) stmt

    )               shift and go to state 77


state 59

    (14) opt_formal_args -> formal_args .

    )               reduce using rule 14 (opt_formal_args -> formal_args .)


state 60

    (15) opt_formal_args -> empty .

    )               reduce using rule 15 (opt_formal_args -> empty .)


state 61

    (5) stmt -> DECLARE ID opt_init opt_semi .

    DECLARE         reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    ID              reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    GET             reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    PUT             reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    RETURN          reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    WHILE           reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    IF              reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    {               reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    $end            reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    }               reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)
    ELSE            reduce using rule 5 (stmt -> DECLARE ID opt_init opt_semi .)


state 62

    (18) opt_init -> = exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    ;               reduce using rule 18 (opt_init -> = exp .)
    DECLARE         reduce using rule 18 (opt_init -> = exp .)
    ID              reduce using rule 18 (opt_init -> = exp .)
    GET             reduce using rule 18 (opt_init -> = exp .)
    PUT             reduce using rule 18 (opt_init -> = exp .)
    RETURN          reduce using rule 18 (opt_init -> = exp .)
    WHILE           reduce using rule 18 (opt_init -> = exp .)
    IF              reduce using rule 18 (opt_init -> = exp .)
    {               reduce using rule 18 (opt_init -> = exp .)
    $end            reduce using rule 18 (opt_init -> = exp .)
    }               reduce using rule 18 (opt_init -> = exp .)
    ELSE            reduce using rule 18 (opt_init -> = exp .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46
    EQ              shift and go to state 47
    LE              shift and go to state 48


state 63

    (6) stmt -> ID = exp opt_semi .

    DECLARE         reduce using rule 6 (stmt -> ID = exp opt_semi .)
    ID              reduce using rule 6 (stmt -> ID = exp opt_semi .)
    GET             reduce using rule 6 (stmt -> ID = exp opt_semi .)
    PUT             reduce using rule 6 (stmt -> ID = exp opt_semi .)
    RETURN          reduce using rule 6 (stmt -> ID = exp opt_semi .)
    WHILE           reduce using rule 6 (stmt -> ID = exp opt_semi .)
    IF              reduce using rule 6 (stmt -> ID = exp opt_semi .)
    {               reduce using rule 6 (stmt -> ID = exp opt_semi .)
    $end            reduce using rule 6 (stmt -> ID = exp opt_semi .)
    }               reduce using rule 6 (stmt -> ID = exp opt_semi .)
    ELSE            reduce using rule 6 (stmt -> ID = exp opt_semi .)


state 64

    (9) stmt -> ID ( opt_actual_args ) . opt_semi
    (28) opt_semi -> . ;
    (29) opt_semi -> . empty
    (42) empty -> .

    ;               shift and go to state 40
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)
    ELSE            reduce using rule 42 (empty -> .)

    opt_semi                       shift and go to state 78
    empty                          shift and go to state 41

state 65

    (22) actual_args -> exp , . actual_args
    (22) actual_args -> . exp , actual_args
    (23) actual_args -> . exp
    (30) exp -> . exp PLUS exp
    (31) exp -> . exp MINUS exp
    (32) exp -> . exp TIMES exp
    (33) exp -> . exp DIVIDE exp
    (34) exp -> . exp EQ exp
    (35) exp -> . exp LE exp
    (36) exp -> . INTEGER
    (37) exp -> . ID
    (38) exp -> . ID ( opt_actual_args )
    (39) exp -> . ( exp )
    (40) exp -> . MINUS exp
    (41) exp -> . NOT exp

    INTEGER         shift and go to state 20
    ID              shift and go to state 21
    (               shift and go to state 22
    MINUS           shift and go to state 19
    NOT             shift and go to state 23

    exp                            shift and go to state 38
    actual_args                    shift and go to state 79

state 66

    (30) exp -> exp PLUS exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 30 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 30 (exp -> exp PLUS exp .)
    EQ              reduce using rule 30 (exp -> exp PLUS exp .)
    LE              reduce using rule 30 (exp -> exp PLUS exp .)
    ;               reduce using rule 30 (exp -> exp PLUS exp .)
    DECLARE         reduce using rule 30 (exp -> exp PLUS exp .)
    ID              reduce using rule 30 (exp -> exp PLUS exp .)
    GET             reduce using rule 30 (exp -> exp PLUS exp .)
    PUT             reduce using rule 30 (exp -> exp PLUS exp .)
    RETURN          reduce using rule 30 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 30 (exp -> exp PLUS exp .)
    IF              reduce using rule 30 (exp -> exp PLUS exp .)
    {               reduce using rule 30 (exp -> exp PLUS exp .)
    $end            reduce using rule 30 (exp -> exp PLUS exp .)
    }               reduce using rule 30 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 30 (exp -> exp PLUS exp .)
    ,               reduce using rule 30 (exp -> exp PLUS exp .)
    )               reduce using rule 30 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! TIMES           [ reduce using rule 30 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 30 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 67

    (31) exp -> exp MINUS exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 31 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 31 (exp -> exp MINUS exp .)
    EQ              reduce using rule 31 (exp -> exp MINUS exp .)
    LE              reduce using rule 31 (exp -> exp MINUS exp .)
    ;               reduce using rule 31 (exp -> exp MINUS exp .)
    DECLARE         reduce using rule 31 (exp -> exp MINUS exp .)
    ID              reduce using rule 31 (exp -> exp MINUS exp .)
    GET             reduce using rule 31 (exp -> exp MINUS exp .)
    PUT             reduce using rule 31 (exp -> exp MINUS exp .)
    RETURN          reduce using rule 31 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 31 (exp -> exp MINUS exp .)
    IF              reduce using rule 31 (exp -> exp MINUS exp .)
    {               reduce using rule 31 (exp -> exp MINUS exp .)
    $end            reduce using rule 31 (exp -> exp MINUS exp .)
    }               reduce using rule 31 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 31 (exp -> exp MINUS exp .)
    ,               reduce using rule 31 (exp -> exp MINUS exp .)
    )               reduce using rule 31 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! TIMES           [ reduce using rule 31 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 31 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 68

    (32) exp -> exp TIMES exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 32 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 32 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 32 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 32 (exp -> exp TIMES exp .)
    EQ              reduce using rule 32 (exp -> exp TIMES exp .)
    LE              reduce using rule 32 (exp -> exp TIMES exp .)
    ;               reduce using rule 32 (exp -> exp TIMES exp .)
    DECLARE         reduce using rule 32 (exp -> exp TIMES exp .)
    ID              reduce using rule 32 (exp -> exp TIMES exp .)
    GET             reduce using rule 32 (exp -> exp TIMES exp .)
    PUT             reduce using rule 32 (exp -> exp TIMES exp .)
    RETURN          reduce using rule 32 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 32 (exp -> exp TIMES exp .)
    IF              reduce using rule 32 (exp -> exp TIMES exp .)
    {               reduce using rule 32 (exp -> exp TIMES exp .)
    $end            reduce using rule 32 (exp -> exp TIMES exp .)
    }               reduce using rule 32 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 32 (exp -> exp TIMES exp .)
    ,               reduce using rule 32 (exp -> exp TIMES exp .)
    )               reduce using rule 32 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! TIMES           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 46 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 69

    (33) exp -> exp DIVIDE exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    PLUS            reduce using rule 33 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 33 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 33 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 33 (exp -> exp DIVIDE exp .)
    EQ              reduce using rule 33 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 33 (exp -> exp DIVIDE exp .)
    ;               reduce using rule 33 (exp -> exp DIVIDE exp .)
    DECLARE         reduce using rule 33 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 33 (exp -> exp DIVIDE exp .)
    GET             reduce using rule 33 (exp -> exp DIVIDE exp .)
    PUT             reduce using rule 33 (exp -> exp DIVIDE exp .)
    RETURN          reduce using rule 33 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 33 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 33 (exp -> exp DIVIDE exp .)
    {               reduce using rule 33 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 33 (exp -> exp DIVIDE exp .)
    }               reduce using rule 33 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 33 (exp -> exp DIVIDE exp .)
    ,               reduce using rule 33 (exp -> exp DIVIDE exp .)
    )               reduce using rule 33 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 43 ]
  ! MINUS           [ shift and go to state 44 ]
  ! TIMES           [ shift and go to state 45 ]
  ! DIVIDE          [ shift and go to state 46 ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 70

    (34) exp -> exp EQ exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    EQ              reduce using rule 34 (exp -> exp EQ exp .)
    LE              reduce using rule 34 (exp -> exp EQ exp .)
    ;               reduce using rule 34 (exp -> exp EQ exp .)
    DECLARE         reduce using rule 34 (exp -> exp EQ exp .)
    ID              reduce using rule 34 (exp -> exp EQ exp .)
    GET             reduce using rule 34 (exp -> exp EQ exp .)
    PUT             reduce using rule 34 (exp -> exp EQ exp .)
    RETURN          reduce using rule 34 (exp -> exp EQ exp .)
    WHILE           reduce using rule 34 (exp -> exp EQ exp .)
    IF              reduce using rule 34 (exp -> exp EQ exp .)
    {               reduce using rule 34 (exp -> exp EQ exp .)
    $end            reduce using rule 34 (exp -> exp EQ exp .)
    }               reduce using rule 34 (exp -> exp EQ exp .)
    ELSE            reduce using rule 34 (exp -> exp EQ exp .)
    ,               reduce using rule 34 (exp -> exp EQ exp .)
    )               reduce using rule 34 (exp -> exp EQ exp .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! PLUS            [ reduce using rule 34 (exp -> exp EQ exp .) ]
  ! MINUS           [ reduce using rule 34 (exp -> exp EQ exp .) ]
  ! TIMES           [ reduce using rule 34 (exp -> exp EQ exp .) ]
  ! DIVIDE          [ reduce using rule 34 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 71

    (35) exp -> exp LE exp .
    (30) exp -> exp . PLUS exp
    (31) exp -> exp . MINUS exp
    (32) exp -> exp . TIMES exp
    (33) exp -> exp . DIVIDE exp
    (34) exp -> exp . EQ exp
    (35) exp -> exp . LE exp

    EQ              reduce using rule 35 (exp -> exp LE exp .)
    LE              reduce using rule 35 (exp -> exp LE exp .)
    ;               reduce using rule 35 (exp -> exp LE exp .)
    DECLARE         reduce using rule 35 (exp -> exp LE exp .)
    ID              reduce using rule 35 (exp -> exp LE exp .)
    GET             reduce using rule 35 (exp -> exp LE exp .)
    PUT             reduce using rule 35 (exp -> exp LE exp .)
    RETURN          reduce using rule 35 (exp -> exp LE exp .)
    WHILE           reduce using rule 35 (exp -> exp LE exp .)
    IF              reduce using rule 35 (exp -> exp LE exp .)
    {               reduce using rule 35 (exp -> exp LE exp .)
    $end            reduce using rule 35 (exp -> exp LE exp .)
    }               reduce using rule 35 (exp -> exp LE exp .)
    ELSE            reduce using rule 35 (exp -> exp LE exp .)
    ,               reduce using rule 35 (exp -> exp LE exp .)
    )               reduce using rule 35 (exp -> exp LE exp .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    TIMES           shift and go to state 45
    DIVIDE          shift and go to state 46

  ! PLUS            [ reduce using rule 35 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 35 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 35 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 35 (exp -> exp LE exp .) ]
  ! EQ              [ shift and go to state 47 ]
  ! LE              [ shift and go to state 48 ]


state 72

    (38) exp -> ID ( opt_actual_args . )

    )               shift and go to state 80


state 73

    (39) exp -> ( exp ) .

    PLUS            reduce using rule 39 (exp -> ( exp ) .)
    MINUS           reduce using rule 39 (exp -> ( exp ) .)
    TIMES           reduce using rule 39 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 39 (exp -> ( exp ) .)
    EQ              reduce using rule 39 (exp -> ( exp ) .)
    LE              reduce using rule 39 (exp -> ( exp ) .)
    ;               reduce using rule 39 (exp -> ( exp ) .)
    DECLARE         reduce using rule 39 (exp -> ( exp ) .)
    ID              reduce using rule 39 (exp -> ( exp ) .)
    GET             reduce using rule 39 (exp -> ( exp ) .)
    PUT             reduce using rule 39 (exp -> ( exp ) .)
    RETURN          reduce using rule 39 (exp -> ( exp ) .)
    WHILE           reduce using rule 39 (exp -> ( exp ) .)
    IF              reduce using rule 39 (exp -> ( exp ) .)
    {               reduce using rule 39 (exp -> ( exp ) .)
    $end            reduce using rule 39 (exp -> ( exp ) .)
    }               reduce using rule 39 (exp -> ( exp ) .)
    ELSE            reduce using rule 39 (exp -> ( exp ) .)
    ,               reduce using rule 39 (exp -> ( exp ) .)
    )               reduce using rule 39 (exp -> ( exp ) .)


state 74

    (11) stmt -> WHILE ( exp ) . stmt
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12

    stmt                           shift and go to state 81

state 75

    (12) stmt -> IF ( exp ) . stmt opt_else
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12

    stmt                           shift and go to state 82

state 76

    (16) formal_args -> ID , . formal_args
    (16) formal_args -> . ID , formal_args
    (17) formal_args -> . ID

    ID              shift and go to state 57

    formal_args                    shift and go to state 83

state 77

    (4) stmt -> DECLARE ID ( opt_formal_args ) . stmt
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12

    stmt                           shift and go to state 84

state 78

    (9) stmt -> ID ( opt_actual_args ) opt_semi .

    DECLARE         reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    ID              reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    GET             reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    PUT             reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    RETURN          reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    WHILE           reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    IF              reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    {               reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    $end            reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    }               reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)
    ELSE            reduce using rule 9 (stmt -> ID ( opt_actual_args ) opt_semi .)


state 79

    (22) actual_args -> exp , actual_args .

    )               reduce using rule 22 (actual_args -> exp , actual_args .)


state 80

    (38) exp -> ID ( opt_actual_args ) .

    PLUS            reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    MINUS           reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    TIMES           reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    DIVIDE          reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    EQ              reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    LE              reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    ;               reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    DECLARE         reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    ID              reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    GET             reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    PUT             reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    RETURN          reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    WHILE           reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    IF              reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    {               reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    $end            reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    }               reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    ELSE            reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    ,               reduce using rule 38 (exp -> ID ( opt_actual_args ) .)
    )               reduce using rule 38 (exp -> ID ( opt_actual_args ) .)


state 81

    (11) stmt -> WHILE ( exp ) stmt .

    DECLARE         reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    ID              reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    GET             reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    PUT             reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    RETURN          reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    WHILE           reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    IF              reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    {               reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    $end            reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    }               reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)
    ELSE            reduce using rule 11 (stmt -> WHILE ( exp ) stmt .)


state 82

    (12) stmt -> IF ( exp ) stmt . opt_else
    (26) opt_else -> . ELSE stmt
    (27) opt_else -> . empty
    (42) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 86
    DECLARE         reduce using rule 42 (empty -> .)
    ID              reduce using rule 42 (empty -> .)
    GET             reduce using rule 42 (empty -> .)
    PUT             reduce using rule 42 (empty -> .)
    RETURN          reduce using rule 42 (empty -> .)
    WHILE           reduce using rule 42 (empty -> .)
    IF              reduce using rule 42 (empty -> .)
    {               reduce using rule 42 (empty -> .)
    $end            reduce using rule 42 (empty -> .)
    }               reduce using rule 42 (empty -> .)

  ! ELSE            [ reduce using rule 42 (empty -> .) ]

    opt_else                       shift and go to state 85
    empty                          shift and go to state 87

state 83

    (16) formal_args -> ID , formal_args .

    )               reduce using rule 16 (formal_args -> ID , formal_args .)


state 84

    (4) stmt -> DECLARE ID ( opt_formal_args ) stmt .

    DECLARE         reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    ID              reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    GET             reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    PUT             reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    RETURN          reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    WHILE           reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    IF              reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    {               reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    $end            reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    }               reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)
    ELSE            reduce using rule 4 (stmt -> DECLARE ID ( opt_formal_args ) stmt .)


state 85

    (12) stmt -> IF ( exp ) stmt opt_else .

    DECLARE         reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    ID              reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    GET             reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    PUT             reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    RETURN          reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    WHILE           reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    IF              reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    {               reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    $end            reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    }               reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)
    ELSE            reduce using rule 12 (stmt -> IF ( exp ) stmt opt_else .)


state 86

    (26) opt_else -> ELSE . stmt
    (4) stmt -> . DECLARE ID ( opt_formal_args ) stmt
    (5) stmt -> . DECLARE ID opt_init opt_semi
    (6) stmt -> . ID = exp opt_semi
    (7) stmt -> . GET ID opt_semi
    (8) stmt -> . PUT exp opt_semi
    (9) stmt -> . ID ( opt_actual_args ) opt_semi
    (10) stmt -> . RETURN opt_exp opt_semi
    (11) stmt -> . WHILE ( exp ) stmt
    (12) stmt -> . IF ( exp ) stmt opt_else
    (13) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    RETURN          shift and go to state 9
    WHILE           shift and go to state 10
    IF              shift and go to state 11
    {               shift and go to state 12

    stmt                           shift and go to state 88

state 87

    (27) opt_else -> empty .

    DECLARE         reduce using rule 27 (opt_else -> empty .)
    ID              reduce using rule 27 (opt_else -> empty .)
    GET             reduce using rule 27 (opt_else -> empty .)
    PUT             reduce using rule 27 (opt_else -> empty .)
    RETURN          reduce using rule 27 (opt_else -> empty .)
    WHILE           reduce using rule 27 (opt_else -> empty .)
    IF              reduce using rule 27 (opt_else -> empty .)
    {               reduce using rule 27 (opt_else -> empty .)
    $end            reduce using rule 27 (opt_else -> empty .)
    }               reduce using rule 27 (opt_else -> empty .)
    ELSE            reduce using rule 27 (opt_else -> empty .)


state 88

    (26) opt_else -> ELSE stmt .

    DECLARE         reduce using rule 26 (opt_else -> ELSE stmt .)
    ID              reduce using rule 26 (opt_else -> ELSE stmt .)
    GET             reduce using rule 26 (opt_else -> ELSE stmt .)
    PUT             reduce using rule 26 (opt_else -> ELSE stmt .)
    RETURN          reduce using rule 26 (opt_else -> ELSE stmt .)
    WHILE           reduce using rule 26 (opt_else -> ELSE stmt .)
    IF              reduce using rule 26 (opt_else -> ELSE stmt .)
    {               reduce using rule 26 (opt_else -> ELSE stmt .)
    $end            reduce using rule 26 (opt_else -> ELSE stmt .)
    }               reduce using rule 26 (opt_else -> ELSE stmt .)
    ELSE            reduce using rule 26 (opt_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 9 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 82 resolved as shift
