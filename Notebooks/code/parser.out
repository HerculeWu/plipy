Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> ID = exp opt_semi
Rule 5     stmt -> GET ID opt_semi
Rule 6     stmt -> PUT exp opt_semi
Rule 7     stmt -> WHILE ( exp ) stmt
Rule 8     stmt -> IF ( exp ) stmt opt_else
Rule 9     stmt -> { stmt_list }
Rule 10    opt_else -> ELSE stmt
Rule 11    opt_else -> empty
Rule 12    exp -> exp PLUS exp
Rule 13    exp -> exp MINUS exp
Rule 14    exp -> exp TIMES exp
Rule 15    exp -> exp DIVIDE exp
Rule 16    exp -> exp EQ exp
Rule 17    exp -> exp LE exp
Rule 18    exp -> INTEGER
Rule 19    exp -> ID
Rule 20    exp -> ( exp )
Rule 21    exp -> MINUS exp
Rule 22    opt_semi -> ;
Rule 23    opt_semi -> empty
Rule 24    empty -> <empty>

Terminals, with rules where they appear

(                    : 7 8 20
)                    : 7 8 20
;                    : 22
=                    : 4
DIVIDE               : 15
ELSE                 : 10
EQ                   : 16
GET                  : 5
ID                   : 4 5 19
IF                   : 8
INTEGER              : 18
LE                   : 17
MINUS                : 13 21
PLUS                 : 12
PUT                  : 6
TIMES                : 14
WHILE                : 7
error                : 
{                    : 9
}                    : 9

Nonterminals, with rules where they appear

empty                : 3 11 23
exp                  : 4 6 7 8 12 12 13 13 14 14 15 15 16 16 17 17 20 21
opt_else             : 8
opt_semi             : 4 5 6
program              : 0
stmt                 : 2 7 8 10
stmt_list            : 1 2 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (24) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    $end            reduce using rule 24 (empty -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (24) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    $end            reduce using rule 24 (empty -> .)
    }               reduce using rule 24 (empty -> .)

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 11
    empty                          shift and go to state 4

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)
    }               reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> ID . = exp opt_semi

    =               shift and go to state 12


state 6

    (5) stmt -> GET . ID opt_semi

    ID              shift and go to state 13


state 7

    (6) stmt -> PUT . exp opt_semi
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 14

state 8

    (7) stmt -> WHILE . ( exp ) stmt

    (               shift and go to state 19


state 9

    (8) stmt -> IF . ( exp ) stmt opt_else

    (               shift and go to state 20


state 10

    (9) stmt -> { . stmt_list }
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }
    (24) empty -> .

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10
    }               reduce using rule 24 (empty -> .)

    stmt_list                      shift and go to state 21
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 11

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    }               reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 12

    (4) stmt -> ID = . exp opt_semi
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 22

state 13

    (5) stmt -> GET ID . opt_semi
    (22) opt_semi -> . ;
    (23) opt_semi -> . empty
    (24) empty -> .

    ;               shift and go to state 24
    ID              reduce using rule 24 (empty -> .)
    GET             reduce using rule 24 (empty -> .)
    PUT             reduce using rule 24 (empty -> .)
    WHILE           reduce using rule 24 (empty -> .)
    IF              reduce using rule 24 (empty -> .)
    {               reduce using rule 24 (empty -> .)
    $end            reduce using rule 24 (empty -> .)
    }               reduce using rule 24 (empty -> .)
    ELSE            reduce using rule 24 (empty -> .)

    opt_semi                       shift and go to state 23
    empty                          shift and go to state 25

state 14

    (6) stmt -> PUT exp . opt_semi
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp
    (22) opt_semi -> . ;
    (23) opt_semi -> . empty
    (24) empty -> .

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    LE              shift and go to state 32
    ;               shift and go to state 24
    ID              reduce using rule 24 (empty -> .)
    GET             reduce using rule 24 (empty -> .)
    PUT             reduce using rule 24 (empty -> .)
    WHILE           reduce using rule 24 (empty -> .)
    IF              reduce using rule 24 (empty -> .)
    {               reduce using rule 24 (empty -> .)
    $end            reduce using rule 24 (empty -> .)
    }               reduce using rule 24 (empty -> .)
    ELSE            reduce using rule 24 (empty -> .)

    opt_semi                       shift and go to state 26
    empty                          shift and go to state 25

state 15

    (21) exp -> MINUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 33

state 16

    (18) exp -> INTEGER .

    PLUS            reduce using rule 18 (exp -> INTEGER .)
    MINUS           reduce using rule 18 (exp -> INTEGER .)
    TIMES           reduce using rule 18 (exp -> INTEGER .)
    DIVIDE          reduce using rule 18 (exp -> INTEGER .)
    EQ              reduce using rule 18 (exp -> INTEGER .)
    LE              reduce using rule 18 (exp -> INTEGER .)
    ;               reduce using rule 18 (exp -> INTEGER .)
    ID              reduce using rule 18 (exp -> INTEGER .)
    GET             reduce using rule 18 (exp -> INTEGER .)
    PUT             reduce using rule 18 (exp -> INTEGER .)
    WHILE           reduce using rule 18 (exp -> INTEGER .)
    IF              reduce using rule 18 (exp -> INTEGER .)
    {               reduce using rule 18 (exp -> INTEGER .)
    $end            reduce using rule 18 (exp -> INTEGER .)
    }               reduce using rule 18 (exp -> INTEGER .)
    ELSE            reduce using rule 18 (exp -> INTEGER .)
    )               reduce using rule 18 (exp -> INTEGER .)


state 17

    (19) exp -> ID .

    PLUS            reduce using rule 19 (exp -> ID .)
    MINUS           reduce using rule 19 (exp -> ID .)
    TIMES           reduce using rule 19 (exp -> ID .)
    DIVIDE          reduce using rule 19 (exp -> ID .)
    EQ              reduce using rule 19 (exp -> ID .)
    LE              reduce using rule 19 (exp -> ID .)
    ;               reduce using rule 19 (exp -> ID .)
    ID              reduce using rule 19 (exp -> ID .)
    GET             reduce using rule 19 (exp -> ID .)
    PUT             reduce using rule 19 (exp -> ID .)
    WHILE           reduce using rule 19 (exp -> ID .)
    IF              reduce using rule 19 (exp -> ID .)
    {               reduce using rule 19 (exp -> ID .)
    $end            reduce using rule 19 (exp -> ID .)
    }               reduce using rule 19 (exp -> ID .)
    ELSE            reduce using rule 19 (exp -> ID .)
    )               reduce using rule 19 (exp -> ID .)


state 18

    (20) exp -> ( . exp )
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 34

state 19

    (7) stmt -> WHILE ( . exp ) stmt
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 35

state 20

    (8) stmt -> IF ( . exp ) stmt opt_else
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 36

state 21

    (9) stmt -> { stmt_list . }

    }               shift and go to state 37


state 22

    (4) stmt -> ID = exp . opt_semi
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp
    (22) opt_semi -> . ;
    (23) opt_semi -> . empty
    (24) empty -> .

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    LE              shift and go to state 32
    ;               shift and go to state 24
    ID              reduce using rule 24 (empty -> .)
    GET             reduce using rule 24 (empty -> .)
    PUT             reduce using rule 24 (empty -> .)
    WHILE           reduce using rule 24 (empty -> .)
    IF              reduce using rule 24 (empty -> .)
    {               reduce using rule 24 (empty -> .)
    $end            reduce using rule 24 (empty -> .)
    }               reduce using rule 24 (empty -> .)
    ELSE            reduce using rule 24 (empty -> .)

    opt_semi                       shift and go to state 38
    empty                          shift and go to state 25

state 23

    (5) stmt -> GET ID opt_semi .

    ID              reduce using rule 5 (stmt -> GET ID opt_semi .)
    GET             reduce using rule 5 (stmt -> GET ID opt_semi .)
    PUT             reduce using rule 5 (stmt -> GET ID opt_semi .)
    WHILE           reduce using rule 5 (stmt -> GET ID opt_semi .)
    IF              reduce using rule 5 (stmt -> GET ID opt_semi .)
    {               reduce using rule 5 (stmt -> GET ID opt_semi .)
    $end            reduce using rule 5 (stmt -> GET ID opt_semi .)
    }               reduce using rule 5 (stmt -> GET ID opt_semi .)
    ELSE            reduce using rule 5 (stmt -> GET ID opt_semi .)


state 24

    (22) opt_semi -> ; .

    ID              reduce using rule 22 (opt_semi -> ; .)
    GET             reduce using rule 22 (opt_semi -> ; .)
    PUT             reduce using rule 22 (opt_semi -> ; .)
    WHILE           reduce using rule 22 (opt_semi -> ; .)
    IF              reduce using rule 22 (opt_semi -> ; .)
    {               reduce using rule 22 (opt_semi -> ; .)
    $end            reduce using rule 22 (opt_semi -> ; .)
    }               reduce using rule 22 (opt_semi -> ; .)
    ELSE            reduce using rule 22 (opt_semi -> ; .)


state 25

    (23) opt_semi -> empty .

    ID              reduce using rule 23 (opt_semi -> empty .)
    GET             reduce using rule 23 (opt_semi -> empty .)
    PUT             reduce using rule 23 (opt_semi -> empty .)
    WHILE           reduce using rule 23 (opt_semi -> empty .)
    IF              reduce using rule 23 (opt_semi -> empty .)
    {               reduce using rule 23 (opt_semi -> empty .)
    $end            reduce using rule 23 (opt_semi -> empty .)
    }               reduce using rule 23 (opt_semi -> empty .)
    ELSE            reduce using rule 23 (opt_semi -> empty .)


state 26

    (6) stmt -> PUT exp opt_semi .

    ID              reduce using rule 6 (stmt -> PUT exp opt_semi .)
    GET             reduce using rule 6 (stmt -> PUT exp opt_semi .)
    PUT             reduce using rule 6 (stmt -> PUT exp opt_semi .)
    WHILE           reduce using rule 6 (stmt -> PUT exp opt_semi .)
    IF              reduce using rule 6 (stmt -> PUT exp opt_semi .)
    {               reduce using rule 6 (stmt -> PUT exp opt_semi .)
    $end            reduce using rule 6 (stmt -> PUT exp opt_semi .)
    }               reduce using rule 6 (stmt -> PUT exp opt_semi .)
    ELSE            reduce using rule 6 (stmt -> PUT exp opt_semi .)


state 27

    (12) exp -> exp PLUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 39

state 28

    (13) exp -> exp MINUS . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 40

state 29

    (14) exp -> exp TIMES . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 41

state 30

    (15) exp -> exp DIVIDE . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 42

state 31

    (16) exp -> exp EQ . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 43

state 32

    (17) exp -> exp LE . exp
    (12) exp -> . exp PLUS exp
    (13) exp -> . exp MINUS exp
    (14) exp -> . exp TIMES exp
    (15) exp -> . exp DIVIDE exp
    (16) exp -> . exp EQ exp
    (17) exp -> . exp LE exp
    (18) exp -> . INTEGER
    (19) exp -> . ID
    (20) exp -> . ( exp )
    (21) exp -> . MINUS exp

    INTEGER         shift and go to state 16
    ID              shift and go to state 17
    (               shift and go to state 18
    MINUS           shift and go to state 15

    exp                            shift and go to state 44

state 33

    (21) exp -> MINUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 21 (exp -> MINUS exp .)
    MINUS           reduce using rule 21 (exp -> MINUS exp .)
    TIMES           reduce using rule 21 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 21 (exp -> MINUS exp .)
    EQ              reduce using rule 21 (exp -> MINUS exp .)
    LE              reduce using rule 21 (exp -> MINUS exp .)
    ;               reduce using rule 21 (exp -> MINUS exp .)
    ID              reduce using rule 21 (exp -> MINUS exp .)
    GET             reduce using rule 21 (exp -> MINUS exp .)
    PUT             reduce using rule 21 (exp -> MINUS exp .)
    WHILE           reduce using rule 21 (exp -> MINUS exp .)
    IF              reduce using rule 21 (exp -> MINUS exp .)
    {               reduce using rule 21 (exp -> MINUS exp .)
    $end            reduce using rule 21 (exp -> MINUS exp .)
    }               reduce using rule 21 (exp -> MINUS exp .)
    ELSE            reduce using rule 21 (exp -> MINUS exp .)
    )               reduce using rule 21 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 34

    (20) exp -> ( exp . )
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 45
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    LE              shift and go to state 32


state 35

    (7) stmt -> WHILE ( exp . ) stmt
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 46
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    LE              shift and go to state 32


state 36

    (8) stmt -> IF ( exp . ) stmt opt_else
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    )               shift and go to state 47
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    EQ              shift and go to state 31
    LE              shift and go to state 32


state 37

    (9) stmt -> { stmt_list } .

    ID              reduce using rule 9 (stmt -> { stmt_list } .)
    GET             reduce using rule 9 (stmt -> { stmt_list } .)
    PUT             reduce using rule 9 (stmt -> { stmt_list } .)
    WHILE           reduce using rule 9 (stmt -> { stmt_list } .)
    IF              reduce using rule 9 (stmt -> { stmt_list } .)
    {               reduce using rule 9 (stmt -> { stmt_list } .)
    $end            reduce using rule 9 (stmt -> { stmt_list } .)
    }               reduce using rule 9 (stmt -> { stmt_list } .)
    ELSE            reduce using rule 9 (stmt -> { stmt_list } .)


state 38

    (4) stmt -> ID = exp opt_semi .

    ID              reduce using rule 4 (stmt -> ID = exp opt_semi .)
    GET             reduce using rule 4 (stmt -> ID = exp opt_semi .)
    PUT             reduce using rule 4 (stmt -> ID = exp opt_semi .)
    WHILE           reduce using rule 4 (stmt -> ID = exp opt_semi .)
    IF              reduce using rule 4 (stmt -> ID = exp opt_semi .)
    {               reduce using rule 4 (stmt -> ID = exp opt_semi .)
    $end            reduce using rule 4 (stmt -> ID = exp opt_semi .)
    }               reduce using rule 4 (stmt -> ID = exp opt_semi .)
    ELSE            reduce using rule 4 (stmt -> ID = exp opt_semi .)


state 39

    (12) exp -> exp PLUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 12 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 12 (exp -> exp PLUS exp .)
    EQ              reduce using rule 12 (exp -> exp PLUS exp .)
    LE              reduce using rule 12 (exp -> exp PLUS exp .)
    ;               reduce using rule 12 (exp -> exp PLUS exp .)
    ID              reduce using rule 12 (exp -> exp PLUS exp .)
    GET             reduce using rule 12 (exp -> exp PLUS exp .)
    PUT             reduce using rule 12 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 12 (exp -> exp PLUS exp .)
    IF              reduce using rule 12 (exp -> exp PLUS exp .)
    {               reduce using rule 12 (exp -> exp PLUS exp .)
    $end            reduce using rule 12 (exp -> exp PLUS exp .)
    }               reduce using rule 12 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 12 (exp -> exp PLUS exp .)
    )               reduce using rule 12 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! TIMES           [ reduce using rule 12 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 12 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 40

    (13) exp -> exp MINUS exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 13 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 13 (exp -> exp MINUS exp .)
    EQ              reduce using rule 13 (exp -> exp MINUS exp .)
    LE              reduce using rule 13 (exp -> exp MINUS exp .)
    ;               reduce using rule 13 (exp -> exp MINUS exp .)
    ID              reduce using rule 13 (exp -> exp MINUS exp .)
    GET             reduce using rule 13 (exp -> exp MINUS exp .)
    PUT             reduce using rule 13 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 13 (exp -> exp MINUS exp .)
    IF              reduce using rule 13 (exp -> exp MINUS exp .)
    {               reduce using rule 13 (exp -> exp MINUS exp .)
    $end            reduce using rule 13 (exp -> exp MINUS exp .)
    }               reduce using rule 13 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 13 (exp -> exp MINUS exp .)
    )               reduce using rule 13 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! TIMES           [ reduce using rule 13 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 13 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 41

    (14) exp -> exp TIMES exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 14 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 14 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 14 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 14 (exp -> exp TIMES exp .)
    EQ              reduce using rule 14 (exp -> exp TIMES exp .)
    LE              reduce using rule 14 (exp -> exp TIMES exp .)
    ;               reduce using rule 14 (exp -> exp TIMES exp .)
    ID              reduce using rule 14 (exp -> exp TIMES exp .)
    GET             reduce using rule 14 (exp -> exp TIMES exp .)
    PUT             reduce using rule 14 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 14 (exp -> exp TIMES exp .)
    IF              reduce using rule 14 (exp -> exp TIMES exp .)
    {               reduce using rule 14 (exp -> exp TIMES exp .)
    $end            reduce using rule 14 (exp -> exp TIMES exp .)
    }               reduce using rule 14 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 14 (exp -> exp TIMES exp .)
    )               reduce using rule 14 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 42

    (15) exp -> exp DIVIDE exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    PLUS            reduce using rule 15 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 15 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 15 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 15 (exp -> exp DIVIDE exp .)
    EQ              reduce using rule 15 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 15 (exp -> exp DIVIDE exp .)
    ;               reduce using rule 15 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 15 (exp -> exp DIVIDE exp .)
    GET             reduce using rule 15 (exp -> exp DIVIDE exp .)
    PUT             reduce using rule 15 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 15 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 15 (exp -> exp DIVIDE exp .)
    {               reduce using rule 15 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 15 (exp -> exp DIVIDE exp .)
    }               reduce using rule 15 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 15 (exp -> exp DIVIDE exp .)
    )               reduce using rule 15 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 43

    (16) exp -> exp EQ exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    EQ              reduce using rule 16 (exp -> exp EQ exp .)
    LE              reduce using rule 16 (exp -> exp EQ exp .)
    ;               reduce using rule 16 (exp -> exp EQ exp .)
    ID              reduce using rule 16 (exp -> exp EQ exp .)
    GET             reduce using rule 16 (exp -> exp EQ exp .)
    PUT             reduce using rule 16 (exp -> exp EQ exp .)
    WHILE           reduce using rule 16 (exp -> exp EQ exp .)
    IF              reduce using rule 16 (exp -> exp EQ exp .)
    {               reduce using rule 16 (exp -> exp EQ exp .)
    $end            reduce using rule 16 (exp -> exp EQ exp .)
    }               reduce using rule 16 (exp -> exp EQ exp .)
    ELSE            reduce using rule 16 (exp -> exp EQ exp .)
    )               reduce using rule 16 (exp -> exp EQ exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! PLUS            [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! MINUS           [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! TIMES           [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! DIVIDE          [ reduce using rule 16 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 44

    (17) exp -> exp LE exp .
    (12) exp -> exp . PLUS exp
    (13) exp -> exp . MINUS exp
    (14) exp -> exp . TIMES exp
    (15) exp -> exp . DIVIDE exp
    (16) exp -> exp . EQ exp
    (17) exp -> exp . LE exp

    EQ              reduce using rule 17 (exp -> exp LE exp .)
    LE              reduce using rule 17 (exp -> exp LE exp .)
    ;               reduce using rule 17 (exp -> exp LE exp .)
    ID              reduce using rule 17 (exp -> exp LE exp .)
    GET             reduce using rule 17 (exp -> exp LE exp .)
    PUT             reduce using rule 17 (exp -> exp LE exp .)
    WHILE           reduce using rule 17 (exp -> exp LE exp .)
    IF              reduce using rule 17 (exp -> exp LE exp .)
    {               reduce using rule 17 (exp -> exp LE exp .)
    $end            reduce using rule 17 (exp -> exp LE exp .)
    }               reduce using rule 17 (exp -> exp LE exp .)
    ELSE            reduce using rule 17 (exp -> exp LE exp .)
    )               reduce using rule 17 (exp -> exp LE exp .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30

  ! PLUS            [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 17 (exp -> exp LE exp .) ]
  ! EQ              [ shift and go to state 31 ]
  ! LE              [ shift and go to state 32 ]


state 45

    (20) exp -> ( exp ) .

    PLUS            reduce using rule 20 (exp -> ( exp ) .)
    MINUS           reduce using rule 20 (exp -> ( exp ) .)
    TIMES           reduce using rule 20 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 20 (exp -> ( exp ) .)
    EQ              reduce using rule 20 (exp -> ( exp ) .)
    LE              reduce using rule 20 (exp -> ( exp ) .)
    ;               reduce using rule 20 (exp -> ( exp ) .)
    ID              reduce using rule 20 (exp -> ( exp ) .)
    GET             reduce using rule 20 (exp -> ( exp ) .)
    PUT             reduce using rule 20 (exp -> ( exp ) .)
    WHILE           reduce using rule 20 (exp -> ( exp ) .)
    IF              reduce using rule 20 (exp -> ( exp ) .)
    {               reduce using rule 20 (exp -> ( exp ) .)
    $end            reduce using rule 20 (exp -> ( exp ) .)
    }               reduce using rule 20 (exp -> ( exp ) .)
    ELSE            reduce using rule 20 (exp -> ( exp ) .)
    )               reduce using rule 20 (exp -> ( exp ) .)


state 46

    (7) stmt -> WHILE ( exp ) . stmt
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 48

state 47

    (8) stmt -> IF ( exp ) . stmt opt_else
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 49

state 48

    (7) stmt -> WHILE ( exp ) stmt .

    ID              reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    GET             reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    PUT             reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    WHILE           reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    IF              reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    {               reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    $end            reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    }               reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)
    ELSE            reduce using rule 7 (stmt -> WHILE ( exp ) stmt .)


state 49

    (8) stmt -> IF ( exp ) stmt . opt_else
    (10) opt_else -> . ELSE stmt
    (11) opt_else -> . empty
    (24) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 51
    ID              reduce using rule 24 (empty -> .)
    GET             reduce using rule 24 (empty -> .)
    PUT             reduce using rule 24 (empty -> .)
    WHILE           reduce using rule 24 (empty -> .)
    IF              reduce using rule 24 (empty -> .)
    {               reduce using rule 24 (empty -> .)
    $end            reduce using rule 24 (empty -> .)
    }               reduce using rule 24 (empty -> .)

  ! ELSE            [ reduce using rule 24 (empty -> .) ]

    opt_else                       shift and go to state 50
    empty                          shift and go to state 52

state 50

    (8) stmt -> IF ( exp ) stmt opt_else .

    ID              reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    GET             reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    PUT             reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    WHILE           reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    IF              reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    {               reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    $end            reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    }               reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)
    ELSE            reduce using rule 8 (stmt -> IF ( exp ) stmt opt_else .)


state 51

    (10) opt_else -> ELSE . stmt
    (4) stmt -> . ID = exp opt_semi
    (5) stmt -> . GET ID opt_semi
    (6) stmt -> . PUT exp opt_semi
    (7) stmt -> . WHILE ( exp ) stmt
    (8) stmt -> . IF ( exp ) stmt opt_else
    (9) stmt -> . { stmt_list }

    ID              shift and go to state 5
    GET             shift and go to state 6
    PUT             shift and go to state 7
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    {               shift and go to state 10

    stmt                           shift and go to state 53

state 52

    (11) opt_else -> empty .

    ID              reduce using rule 11 (opt_else -> empty .)
    GET             reduce using rule 11 (opt_else -> empty .)
    PUT             reduce using rule 11 (opt_else -> empty .)
    WHILE           reduce using rule 11 (opt_else -> empty .)
    IF              reduce using rule 11 (opt_else -> empty .)
    {               reduce using rule 11 (opt_else -> empty .)
    $end            reduce using rule 11 (opt_else -> empty .)
    }               reduce using rule 11 (opt_else -> empty .)
    ELSE            reduce using rule 11 (opt_else -> empty .)


state 53

    (10) opt_else -> ELSE stmt .

    ID              reduce using rule 10 (opt_else -> ELSE stmt .)
    GET             reduce using rule 10 (opt_else -> ELSE stmt .)
    PUT             reduce using rule 10 (opt_else -> ELSE stmt .)
    WHILE           reduce using rule 10 (opt_else -> ELSE stmt .)
    IF              reduce using rule 10 (opt_else -> ELSE stmt .)
    {               reduce using rule 10 (opt_else -> ELSE stmt .)
    $end            reduce using rule 10 (opt_else -> ELSE stmt .)
    }               reduce using rule 10 (opt_else -> ELSE stmt .)
    ELSE            reduce using rule 10 (opt_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 49 resolved as shift
