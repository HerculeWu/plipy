Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> DECLARE ID opt_init opt_semi
Rule 5     stmt -> ID = exp opt_semi
Rule 6     stmt -> GET ID opt_semi
Rule 7     stmt -> PUT exp opt_semi
Rule 8     stmt -> WHILE ( exp ) stmt
Rule 9     stmt -> IF ( exp ) stmt opt_else
Rule 10    stmt -> { stmt_list }
Rule 11    opt_init -> = exp
Rule 12    opt_init -> empty
Rule 13    opt_else -> ELSE stmt
Rule 14    opt_else -> empty
Rule 15    opt_semi -> ;
Rule 16    opt_semi -> empty
Rule 17    exp -> exp PLUS exp
Rule 18    exp -> exp MINUS exp
Rule 19    exp -> exp TIMES exp
Rule 20    exp -> exp DIVIDE exp
Rule 21    exp -> exp EQ exp
Rule 22    exp -> exp LE exp
Rule 23    exp -> INTEGER
Rule 24    exp -> ID
Rule 25    exp -> ( exp )
Rule 26    exp -> MINUS exp
Rule 27    exp -> NOT exp
Rule 28    empty -> <empty>

Terminals, with rules where they appear

(                    : 8 9 25
)                    : 8 9 25
;                    : 15
=                    : 5 11
DECLARE              : 4
DIVIDE               : 20
ELSE                 : 13
EQ                   : 21
GET                  : 6
ID                   : 4 5 6 24
IF                   : 9
INTEGER              : 23
LE                   : 22
MINUS                : 18 26
NOT                  : 27
PLUS                 : 17
PUT                  : 7
TIMES                : 19
WHILE                : 8
error                : 
{                    : 10
}                    : 10

Nonterminals, with rules where they appear

empty                : 3 12 14 16
exp                  : 5 7 8 9 11 17 17 18 18 19 19 20 20 21 21 22 22 25 26 27
opt_else             : 9
opt_init             : 4
opt_semi             : 4 5 6 7
program              : 0
stmt                 : 2 8 9 13
stmt_list            : 1 2 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }
    (28) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11
    $end            reduce using rule 28 (empty -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }
    (28) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 12
    empty                          shift and go to state 4

state 4

    (3) stmt_list -> empty .

    $end            reduce using rule 3 (stmt_list -> empty .)
    }               reduce using rule 3 (stmt_list -> empty .)


state 5

    (4) stmt -> DECLARE . ID opt_init opt_semi

    ID              shift and go to state 13


state 6

    (5) stmt -> ID . = exp opt_semi

    =               shift and go to state 14


state 7

    (6) stmt -> GET . ID opt_semi

    ID              shift and go to state 15


state 8

    (7) stmt -> PUT . exp opt_semi
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 16

state 9

    (8) stmt -> WHILE . ( exp ) stmt

    (               shift and go to state 22


state 10

    (9) stmt -> IF . ( exp ) stmt opt_else

    (               shift and go to state 23


state 11

    (10) stmt -> { . stmt_list }
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }
    (28) empty -> .

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11
    }               reduce using rule 28 (empty -> .)

    stmt_list                      shift and go to state 24
    stmt                           shift and go to state 3
    empty                          shift and go to state 4

state 12

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    }               reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 13

    (4) stmt -> DECLARE ID . opt_init opt_semi
    (11) opt_init -> . = exp
    (12) opt_init -> . empty
    (28) empty -> .

    =               shift and go to state 26
    ;               reduce using rule 28 (empty -> .)
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)
    ELSE            reduce using rule 28 (empty -> .)

    opt_init                       shift and go to state 25
    empty                          shift and go to state 27

state 14

    (5) stmt -> ID = . exp opt_semi
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 28

state 15

    (6) stmt -> GET ID . opt_semi
    (15) opt_semi -> . ;
    (16) opt_semi -> . empty
    (28) empty -> .

    ;               shift and go to state 30
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)
    ELSE            reduce using rule 28 (empty -> .)

    opt_semi                       shift and go to state 29
    empty                          shift and go to state 31

state 16

    (7) stmt -> PUT exp . opt_semi
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp
    (15) opt_semi -> . ;
    (16) opt_semi -> . empty
    (28) empty -> .

    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38
    ;               shift and go to state 30
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)
    ELSE            reduce using rule 28 (empty -> .)

    opt_semi                       shift and go to state 32
    empty                          shift and go to state 31

state 17

    (26) exp -> MINUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 39

state 18

    (23) exp -> INTEGER .

    PLUS            reduce using rule 23 (exp -> INTEGER .)
    MINUS           reduce using rule 23 (exp -> INTEGER .)
    TIMES           reduce using rule 23 (exp -> INTEGER .)
    DIVIDE          reduce using rule 23 (exp -> INTEGER .)
    EQ              reduce using rule 23 (exp -> INTEGER .)
    LE              reduce using rule 23 (exp -> INTEGER .)
    ;               reduce using rule 23 (exp -> INTEGER .)
    DECLARE         reduce using rule 23 (exp -> INTEGER .)
    ID              reduce using rule 23 (exp -> INTEGER .)
    GET             reduce using rule 23 (exp -> INTEGER .)
    PUT             reduce using rule 23 (exp -> INTEGER .)
    WHILE           reduce using rule 23 (exp -> INTEGER .)
    IF              reduce using rule 23 (exp -> INTEGER .)
    {               reduce using rule 23 (exp -> INTEGER .)
    $end            reduce using rule 23 (exp -> INTEGER .)
    }               reduce using rule 23 (exp -> INTEGER .)
    ELSE            reduce using rule 23 (exp -> INTEGER .)
    )               reduce using rule 23 (exp -> INTEGER .)


state 19

    (24) exp -> ID .

    PLUS            reduce using rule 24 (exp -> ID .)
    MINUS           reduce using rule 24 (exp -> ID .)
    TIMES           reduce using rule 24 (exp -> ID .)
    DIVIDE          reduce using rule 24 (exp -> ID .)
    EQ              reduce using rule 24 (exp -> ID .)
    LE              reduce using rule 24 (exp -> ID .)
    ;               reduce using rule 24 (exp -> ID .)
    DECLARE         reduce using rule 24 (exp -> ID .)
    ID              reduce using rule 24 (exp -> ID .)
    GET             reduce using rule 24 (exp -> ID .)
    PUT             reduce using rule 24 (exp -> ID .)
    WHILE           reduce using rule 24 (exp -> ID .)
    IF              reduce using rule 24 (exp -> ID .)
    {               reduce using rule 24 (exp -> ID .)
    $end            reduce using rule 24 (exp -> ID .)
    }               reduce using rule 24 (exp -> ID .)
    ELSE            reduce using rule 24 (exp -> ID .)
    )               reduce using rule 24 (exp -> ID .)


state 20

    (25) exp -> ( . exp )
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 40

state 21

    (27) exp -> NOT . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 41

state 22

    (8) stmt -> WHILE ( . exp ) stmt
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 42

state 23

    (9) stmt -> IF ( . exp ) stmt opt_else
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 43

state 24

    (10) stmt -> { stmt_list . }

    }               shift and go to state 44


state 25

    (4) stmt -> DECLARE ID opt_init . opt_semi
    (15) opt_semi -> . ;
    (16) opt_semi -> . empty
    (28) empty -> .

    ;               shift and go to state 30
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)
    ELSE            reduce using rule 28 (empty -> .)

    opt_semi                       shift and go to state 45
    empty                          shift and go to state 31

state 26

    (11) opt_init -> = . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 46

state 27

    (12) opt_init -> empty .

    ;               reduce using rule 12 (opt_init -> empty .)
    DECLARE         reduce using rule 12 (opt_init -> empty .)
    ID              reduce using rule 12 (opt_init -> empty .)
    GET             reduce using rule 12 (opt_init -> empty .)
    PUT             reduce using rule 12 (opt_init -> empty .)
    WHILE           reduce using rule 12 (opt_init -> empty .)
    IF              reduce using rule 12 (opt_init -> empty .)
    {               reduce using rule 12 (opt_init -> empty .)
    $end            reduce using rule 12 (opt_init -> empty .)
    }               reduce using rule 12 (opt_init -> empty .)
    ELSE            reduce using rule 12 (opt_init -> empty .)


state 28

    (5) stmt -> ID = exp . opt_semi
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp
    (15) opt_semi -> . ;
    (16) opt_semi -> . empty
    (28) empty -> .

    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38
    ;               shift and go to state 30
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)
    ELSE            reduce using rule 28 (empty -> .)

    opt_semi                       shift and go to state 47
    empty                          shift and go to state 31

state 29

    (6) stmt -> GET ID opt_semi .

    DECLARE         reduce using rule 6 (stmt -> GET ID opt_semi .)
    ID              reduce using rule 6 (stmt -> GET ID opt_semi .)
    GET             reduce using rule 6 (stmt -> GET ID opt_semi .)
    PUT             reduce using rule 6 (stmt -> GET ID opt_semi .)
    WHILE           reduce using rule 6 (stmt -> GET ID opt_semi .)
    IF              reduce using rule 6 (stmt -> GET ID opt_semi .)
    {               reduce using rule 6 (stmt -> GET ID opt_semi .)
    $end            reduce using rule 6 (stmt -> GET ID opt_semi .)
    }               reduce using rule 6 (stmt -> GET ID opt_semi .)
    ELSE            reduce using rule 6 (stmt -> GET ID opt_semi .)


state 30

    (15) opt_semi -> ; .

    DECLARE         reduce using rule 15 (opt_semi -> ; .)
    ID              reduce using rule 15 (opt_semi -> ; .)
    GET             reduce using rule 15 (opt_semi -> ; .)
    PUT             reduce using rule 15 (opt_semi -> ; .)
    WHILE           reduce using rule 15 (opt_semi -> ; .)
    IF              reduce using rule 15 (opt_semi -> ; .)
    {               reduce using rule 15 (opt_semi -> ; .)
    $end            reduce using rule 15 (opt_semi -> ; .)
    }               reduce using rule 15 (opt_semi -> ; .)
    ELSE            reduce using rule 15 (opt_semi -> ; .)


state 31

    (16) opt_semi -> empty .

    DECLARE         reduce using rule 16 (opt_semi -> empty .)
    ID              reduce using rule 16 (opt_semi -> empty .)
    GET             reduce using rule 16 (opt_semi -> empty .)
    PUT             reduce using rule 16 (opt_semi -> empty .)
    WHILE           reduce using rule 16 (opt_semi -> empty .)
    IF              reduce using rule 16 (opt_semi -> empty .)
    {               reduce using rule 16 (opt_semi -> empty .)
    $end            reduce using rule 16 (opt_semi -> empty .)
    }               reduce using rule 16 (opt_semi -> empty .)
    ELSE            reduce using rule 16 (opt_semi -> empty .)


state 32

    (7) stmt -> PUT exp opt_semi .

    DECLARE         reduce using rule 7 (stmt -> PUT exp opt_semi .)
    ID              reduce using rule 7 (stmt -> PUT exp opt_semi .)
    GET             reduce using rule 7 (stmt -> PUT exp opt_semi .)
    PUT             reduce using rule 7 (stmt -> PUT exp opt_semi .)
    WHILE           reduce using rule 7 (stmt -> PUT exp opt_semi .)
    IF              reduce using rule 7 (stmt -> PUT exp opt_semi .)
    {               reduce using rule 7 (stmt -> PUT exp opt_semi .)
    $end            reduce using rule 7 (stmt -> PUT exp opt_semi .)
    }               reduce using rule 7 (stmt -> PUT exp opt_semi .)
    ELSE            reduce using rule 7 (stmt -> PUT exp opt_semi .)


state 33

    (17) exp -> exp PLUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 48

state 34

    (18) exp -> exp MINUS . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 49

state 35

    (19) exp -> exp TIMES . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 50

state 36

    (20) exp -> exp DIVIDE . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 51

state 37

    (21) exp -> exp EQ . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 52

state 38

    (22) exp -> exp LE . exp
    (17) exp -> . exp PLUS exp
    (18) exp -> . exp MINUS exp
    (19) exp -> . exp TIMES exp
    (20) exp -> . exp DIVIDE exp
    (21) exp -> . exp EQ exp
    (22) exp -> . exp LE exp
    (23) exp -> . INTEGER
    (24) exp -> . ID
    (25) exp -> . ( exp )
    (26) exp -> . MINUS exp
    (27) exp -> . NOT exp

    INTEGER         shift and go to state 18
    ID              shift and go to state 19
    (               shift and go to state 20
    MINUS           shift and go to state 17
    NOT             shift and go to state 21

    exp                            shift and go to state 53

state 39

    (26) exp -> MINUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 26 (exp -> MINUS exp .)
    MINUS           reduce using rule 26 (exp -> MINUS exp .)
    TIMES           reduce using rule 26 (exp -> MINUS exp .)
    DIVIDE          reduce using rule 26 (exp -> MINUS exp .)
    EQ              reduce using rule 26 (exp -> MINUS exp .)
    LE              reduce using rule 26 (exp -> MINUS exp .)
    ;               reduce using rule 26 (exp -> MINUS exp .)
    DECLARE         reduce using rule 26 (exp -> MINUS exp .)
    ID              reduce using rule 26 (exp -> MINUS exp .)
    GET             reduce using rule 26 (exp -> MINUS exp .)
    PUT             reduce using rule 26 (exp -> MINUS exp .)
    WHILE           reduce using rule 26 (exp -> MINUS exp .)
    IF              reduce using rule 26 (exp -> MINUS exp .)
    {               reduce using rule 26 (exp -> MINUS exp .)
    $end            reduce using rule 26 (exp -> MINUS exp .)
    }               reduce using rule 26 (exp -> MINUS exp .)
    ELSE            reduce using rule 26 (exp -> MINUS exp .)
    )               reduce using rule 26 (exp -> MINUS exp .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 40

    (25) exp -> ( exp . )
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    )               shift and go to state 54
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38


state 41

    (27) exp -> NOT exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 27 (exp -> NOT exp .)
    MINUS           reduce using rule 27 (exp -> NOT exp .)
    TIMES           reduce using rule 27 (exp -> NOT exp .)
    DIVIDE          reduce using rule 27 (exp -> NOT exp .)
    EQ              reduce using rule 27 (exp -> NOT exp .)
    LE              reduce using rule 27 (exp -> NOT exp .)
    ;               reduce using rule 27 (exp -> NOT exp .)
    DECLARE         reduce using rule 27 (exp -> NOT exp .)
    ID              reduce using rule 27 (exp -> NOT exp .)
    GET             reduce using rule 27 (exp -> NOT exp .)
    PUT             reduce using rule 27 (exp -> NOT exp .)
    WHILE           reduce using rule 27 (exp -> NOT exp .)
    IF              reduce using rule 27 (exp -> NOT exp .)
    {               reduce using rule 27 (exp -> NOT exp .)
    $end            reduce using rule 27 (exp -> NOT exp .)
    }               reduce using rule 27 (exp -> NOT exp .)
    ELSE            reduce using rule 27 (exp -> NOT exp .)
    )               reduce using rule 27 (exp -> NOT exp .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 42

    (8) stmt -> WHILE ( exp . ) stmt
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    )               shift and go to state 55
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38


state 43

    (9) stmt -> IF ( exp . ) stmt opt_else
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    )               shift and go to state 56
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38


state 44

    (10) stmt -> { stmt_list } .

    DECLARE         reduce using rule 10 (stmt -> { stmt_list } .)
    ID              reduce using rule 10 (stmt -> { stmt_list } .)
    GET             reduce using rule 10 (stmt -> { stmt_list } .)
    PUT             reduce using rule 10 (stmt -> { stmt_list } .)
    WHILE           reduce using rule 10 (stmt -> { stmt_list } .)
    IF              reduce using rule 10 (stmt -> { stmt_list } .)
    {               reduce using rule 10 (stmt -> { stmt_list } .)
    $end            reduce using rule 10 (stmt -> { stmt_list } .)
    }               reduce using rule 10 (stmt -> { stmt_list } .)
    ELSE            reduce using rule 10 (stmt -> { stmt_list } .)


state 45

    (4) stmt -> DECLARE ID opt_init opt_semi .

    DECLARE         reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    ID              reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    GET             reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    PUT             reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    WHILE           reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    IF              reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    {               reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    $end            reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    }               reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)
    ELSE            reduce using rule 4 (stmt -> DECLARE ID opt_init opt_semi .)


state 46

    (11) opt_init -> = exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    ;               reduce using rule 11 (opt_init -> = exp .)
    DECLARE         reduce using rule 11 (opt_init -> = exp .)
    ID              reduce using rule 11 (opt_init -> = exp .)
    GET             reduce using rule 11 (opt_init -> = exp .)
    PUT             reduce using rule 11 (opt_init -> = exp .)
    WHILE           reduce using rule 11 (opt_init -> = exp .)
    IF              reduce using rule 11 (opt_init -> = exp .)
    {               reduce using rule 11 (opt_init -> = exp .)
    $end            reduce using rule 11 (opt_init -> = exp .)
    }               reduce using rule 11 (opt_init -> = exp .)
    ELSE            reduce using rule 11 (opt_init -> = exp .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    EQ              shift and go to state 37
    LE              shift and go to state 38


state 47

    (5) stmt -> ID = exp opt_semi .

    DECLARE         reduce using rule 5 (stmt -> ID = exp opt_semi .)
    ID              reduce using rule 5 (stmt -> ID = exp opt_semi .)
    GET             reduce using rule 5 (stmt -> ID = exp opt_semi .)
    PUT             reduce using rule 5 (stmt -> ID = exp opt_semi .)
    WHILE           reduce using rule 5 (stmt -> ID = exp opt_semi .)
    IF              reduce using rule 5 (stmt -> ID = exp opt_semi .)
    {               reduce using rule 5 (stmt -> ID = exp opt_semi .)
    $end            reduce using rule 5 (stmt -> ID = exp opt_semi .)
    }               reduce using rule 5 (stmt -> ID = exp opt_semi .)
    ELSE            reduce using rule 5 (stmt -> ID = exp opt_semi .)


state 48

    (17) exp -> exp PLUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 17 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 17 (exp -> exp PLUS exp .)
    EQ              reduce using rule 17 (exp -> exp PLUS exp .)
    LE              reduce using rule 17 (exp -> exp PLUS exp .)
    ;               reduce using rule 17 (exp -> exp PLUS exp .)
    DECLARE         reduce using rule 17 (exp -> exp PLUS exp .)
    ID              reduce using rule 17 (exp -> exp PLUS exp .)
    GET             reduce using rule 17 (exp -> exp PLUS exp .)
    PUT             reduce using rule 17 (exp -> exp PLUS exp .)
    WHILE           reduce using rule 17 (exp -> exp PLUS exp .)
    IF              reduce using rule 17 (exp -> exp PLUS exp .)
    {               reduce using rule 17 (exp -> exp PLUS exp .)
    $end            reduce using rule 17 (exp -> exp PLUS exp .)
    }               reduce using rule 17 (exp -> exp PLUS exp .)
    ELSE            reduce using rule 17 (exp -> exp PLUS exp .)
    )               reduce using rule 17 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36

  ! TIMES           [ reduce using rule 17 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 17 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 49

    (18) exp -> exp MINUS exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 18 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 18 (exp -> exp MINUS exp .)
    EQ              reduce using rule 18 (exp -> exp MINUS exp .)
    LE              reduce using rule 18 (exp -> exp MINUS exp .)
    ;               reduce using rule 18 (exp -> exp MINUS exp .)
    DECLARE         reduce using rule 18 (exp -> exp MINUS exp .)
    ID              reduce using rule 18 (exp -> exp MINUS exp .)
    GET             reduce using rule 18 (exp -> exp MINUS exp .)
    PUT             reduce using rule 18 (exp -> exp MINUS exp .)
    WHILE           reduce using rule 18 (exp -> exp MINUS exp .)
    IF              reduce using rule 18 (exp -> exp MINUS exp .)
    {               reduce using rule 18 (exp -> exp MINUS exp .)
    $end            reduce using rule 18 (exp -> exp MINUS exp .)
    }               reduce using rule 18 (exp -> exp MINUS exp .)
    ELSE            reduce using rule 18 (exp -> exp MINUS exp .)
    )               reduce using rule 18 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36

  ! TIMES           [ reduce using rule 18 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 18 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 50

    (19) exp -> exp TIMES exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 19 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 19 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 19 (exp -> exp TIMES exp .)
    DIVIDE          reduce using rule 19 (exp -> exp TIMES exp .)
    EQ              reduce using rule 19 (exp -> exp TIMES exp .)
    LE              reduce using rule 19 (exp -> exp TIMES exp .)
    ;               reduce using rule 19 (exp -> exp TIMES exp .)
    DECLARE         reduce using rule 19 (exp -> exp TIMES exp .)
    ID              reduce using rule 19 (exp -> exp TIMES exp .)
    GET             reduce using rule 19 (exp -> exp TIMES exp .)
    PUT             reduce using rule 19 (exp -> exp TIMES exp .)
    WHILE           reduce using rule 19 (exp -> exp TIMES exp .)
    IF              reduce using rule 19 (exp -> exp TIMES exp .)
    {               reduce using rule 19 (exp -> exp TIMES exp .)
    $end            reduce using rule 19 (exp -> exp TIMES exp .)
    }               reduce using rule 19 (exp -> exp TIMES exp .)
    ELSE            reduce using rule 19 (exp -> exp TIMES exp .)
    )               reduce using rule 19 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 51

    (20) exp -> exp DIVIDE exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    PLUS            reduce using rule 20 (exp -> exp DIVIDE exp .)
    MINUS           reduce using rule 20 (exp -> exp DIVIDE exp .)
    TIMES           reduce using rule 20 (exp -> exp DIVIDE exp .)
    DIVIDE          reduce using rule 20 (exp -> exp DIVIDE exp .)
    EQ              reduce using rule 20 (exp -> exp DIVIDE exp .)
    LE              reduce using rule 20 (exp -> exp DIVIDE exp .)
    ;               reduce using rule 20 (exp -> exp DIVIDE exp .)
    DECLARE         reduce using rule 20 (exp -> exp DIVIDE exp .)
    ID              reduce using rule 20 (exp -> exp DIVIDE exp .)
    GET             reduce using rule 20 (exp -> exp DIVIDE exp .)
    PUT             reduce using rule 20 (exp -> exp DIVIDE exp .)
    WHILE           reduce using rule 20 (exp -> exp DIVIDE exp .)
    IF              reduce using rule 20 (exp -> exp DIVIDE exp .)
    {               reduce using rule 20 (exp -> exp DIVIDE exp .)
    $end            reduce using rule 20 (exp -> exp DIVIDE exp .)
    }               reduce using rule 20 (exp -> exp DIVIDE exp .)
    ELSE            reduce using rule 20 (exp -> exp DIVIDE exp .)
    )               reduce using rule 20 (exp -> exp DIVIDE exp .)

  ! PLUS            [ shift and go to state 33 ]
  ! MINUS           [ shift and go to state 34 ]
  ! TIMES           [ shift and go to state 35 ]
  ! DIVIDE          [ shift and go to state 36 ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 52

    (21) exp -> exp EQ exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    EQ              reduce using rule 21 (exp -> exp EQ exp .)
    LE              reduce using rule 21 (exp -> exp EQ exp .)
    ;               reduce using rule 21 (exp -> exp EQ exp .)
    DECLARE         reduce using rule 21 (exp -> exp EQ exp .)
    ID              reduce using rule 21 (exp -> exp EQ exp .)
    GET             reduce using rule 21 (exp -> exp EQ exp .)
    PUT             reduce using rule 21 (exp -> exp EQ exp .)
    WHILE           reduce using rule 21 (exp -> exp EQ exp .)
    IF              reduce using rule 21 (exp -> exp EQ exp .)
    {               reduce using rule 21 (exp -> exp EQ exp .)
    $end            reduce using rule 21 (exp -> exp EQ exp .)
    }               reduce using rule 21 (exp -> exp EQ exp .)
    ELSE            reduce using rule 21 (exp -> exp EQ exp .)
    )               reduce using rule 21 (exp -> exp EQ exp .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36

  ! PLUS            [ reduce using rule 21 (exp -> exp EQ exp .) ]
  ! MINUS           [ reduce using rule 21 (exp -> exp EQ exp .) ]
  ! TIMES           [ reduce using rule 21 (exp -> exp EQ exp .) ]
  ! DIVIDE          [ reduce using rule 21 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 53

    (22) exp -> exp LE exp .
    (17) exp -> exp . PLUS exp
    (18) exp -> exp . MINUS exp
    (19) exp -> exp . TIMES exp
    (20) exp -> exp . DIVIDE exp
    (21) exp -> exp . EQ exp
    (22) exp -> exp . LE exp

    EQ              reduce using rule 22 (exp -> exp LE exp .)
    LE              reduce using rule 22 (exp -> exp LE exp .)
    ;               reduce using rule 22 (exp -> exp LE exp .)
    DECLARE         reduce using rule 22 (exp -> exp LE exp .)
    ID              reduce using rule 22 (exp -> exp LE exp .)
    GET             reduce using rule 22 (exp -> exp LE exp .)
    PUT             reduce using rule 22 (exp -> exp LE exp .)
    WHILE           reduce using rule 22 (exp -> exp LE exp .)
    IF              reduce using rule 22 (exp -> exp LE exp .)
    {               reduce using rule 22 (exp -> exp LE exp .)
    $end            reduce using rule 22 (exp -> exp LE exp .)
    }               reduce using rule 22 (exp -> exp LE exp .)
    ELSE            reduce using rule 22 (exp -> exp LE exp .)
    )               reduce using rule 22 (exp -> exp LE exp .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36

  ! PLUS            [ reduce using rule 22 (exp -> exp LE exp .) ]
  ! MINUS           [ reduce using rule 22 (exp -> exp LE exp .) ]
  ! TIMES           [ reduce using rule 22 (exp -> exp LE exp .) ]
  ! DIVIDE          [ reduce using rule 22 (exp -> exp LE exp .) ]
  ! EQ              [ shift and go to state 37 ]
  ! LE              [ shift and go to state 38 ]


state 54

    (25) exp -> ( exp ) .

    PLUS            reduce using rule 25 (exp -> ( exp ) .)
    MINUS           reduce using rule 25 (exp -> ( exp ) .)
    TIMES           reduce using rule 25 (exp -> ( exp ) .)
    DIVIDE          reduce using rule 25 (exp -> ( exp ) .)
    EQ              reduce using rule 25 (exp -> ( exp ) .)
    LE              reduce using rule 25 (exp -> ( exp ) .)
    ;               reduce using rule 25 (exp -> ( exp ) .)
    DECLARE         reduce using rule 25 (exp -> ( exp ) .)
    ID              reduce using rule 25 (exp -> ( exp ) .)
    GET             reduce using rule 25 (exp -> ( exp ) .)
    PUT             reduce using rule 25 (exp -> ( exp ) .)
    WHILE           reduce using rule 25 (exp -> ( exp ) .)
    IF              reduce using rule 25 (exp -> ( exp ) .)
    {               reduce using rule 25 (exp -> ( exp ) .)
    $end            reduce using rule 25 (exp -> ( exp ) .)
    }               reduce using rule 25 (exp -> ( exp ) .)
    ELSE            reduce using rule 25 (exp -> ( exp ) .)
    )               reduce using rule 25 (exp -> ( exp ) .)


state 55

    (8) stmt -> WHILE ( exp ) . stmt
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11

    stmt                           shift and go to state 57

state 56

    (9) stmt -> IF ( exp ) . stmt opt_else
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11

    stmt                           shift and go to state 58

state 57

    (8) stmt -> WHILE ( exp ) stmt .

    DECLARE         reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    ID              reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    GET             reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    PUT             reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    WHILE           reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    IF              reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    {               reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    $end            reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    }               reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)
    ELSE            reduce using rule 8 (stmt -> WHILE ( exp ) stmt .)


state 58

    (9) stmt -> IF ( exp ) stmt . opt_else
    (13) opt_else -> . ELSE stmt
    (14) opt_else -> . empty
    (28) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 60
    DECLARE         reduce using rule 28 (empty -> .)
    ID              reduce using rule 28 (empty -> .)
    GET             reduce using rule 28 (empty -> .)
    PUT             reduce using rule 28 (empty -> .)
    WHILE           reduce using rule 28 (empty -> .)
    IF              reduce using rule 28 (empty -> .)
    {               reduce using rule 28 (empty -> .)
    $end            reduce using rule 28 (empty -> .)
    }               reduce using rule 28 (empty -> .)

  ! ELSE            [ reduce using rule 28 (empty -> .) ]

    opt_else                       shift and go to state 59
    empty                          shift and go to state 61

state 59

    (9) stmt -> IF ( exp ) stmt opt_else .

    DECLARE         reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    ID              reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    GET             reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    PUT             reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    WHILE           reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    IF              reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    {               reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    $end            reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    }               reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)
    ELSE            reduce using rule 9 (stmt -> IF ( exp ) stmt opt_else .)


state 60

    (13) opt_else -> ELSE . stmt
    (4) stmt -> . DECLARE ID opt_init opt_semi
    (5) stmt -> . ID = exp opt_semi
    (6) stmt -> . GET ID opt_semi
    (7) stmt -> . PUT exp opt_semi
    (8) stmt -> . WHILE ( exp ) stmt
    (9) stmt -> . IF ( exp ) stmt opt_else
    (10) stmt -> . { stmt_list }

    DECLARE         shift and go to state 5
    ID              shift and go to state 6
    GET             shift and go to state 7
    PUT             shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10
    {               shift and go to state 11

    stmt                           shift and go to state 62

state 61

    (14) opt_else -> empty .

    DECLARE         reduce using rule 14 (opt_else -> empty .)
    ID              reduce using rule 14 (opt_else -> empty .)
    GET             reduce using rule 14 (opt_else -> empty .)
    PUT             reduce using rule 14 (opt_else -> empty .)
    WHILE           reduce using rule 14 (opt_else -> empty .)
    IF              reduce using rule 14 (opt_else -> empty .)
    {               reduce using rule 14 (opt_else -> empty .)
    $end            reduce using rule 14 (opt_else -> empty .)
    }               reduce using rule 14 (opt_else -> empty .)
    ELSE            reduce using rule 14 (opt_else -> empty .)


state 62

    (13) opt_else -> ELSE stmt .

    DECLARE         reduce using rule 13 (opt_else -> ELSE stmt .)
    ID              reduce using rule 13 (opt_else -> ELSE stmt .)
    GET             reduce using rule 13 (opt_else -> ELSE stmt .)
    PUT             reduce using rule 13 (opt_else -> ELSE stmt .)
    WHILE           reduce using rule 13 (opt_else -> ELSE stmt .)
    IF              reduce using rule 13 (opt_else -> ELSE stmt .)
    {               reduce using rule 13 (opt_else -> ELSE stmt .)
    $end            reduce using rule 13 (opt_else -> ELSE stmt .)
    }               reduce using rule 13 (opt_else -> ELSE stmt .)
    ELSE            reduce using rule 13 (opt_else -> ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 58 resolved as shift
